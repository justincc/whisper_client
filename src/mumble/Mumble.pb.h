// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Mumble.proto

#ifndef PROTOBUF_Mumble_2eproto__INCLUDED
#define PROTOBUF_Mumble_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace MumbleProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Mumble_2eproto();
void protobuf_AssignDesc_Mumble_2eproto();
void protobuf_ShutdownFile_Mumble_2eproto();

class Version;
class UDPTunnel;
class Authenticate;
class Ping;
class Reject;
class ServerSync;
class ChannelRemove;
class ChannelState;
class UserRemove;
class UserState;
class BanList;
class BanList_BanEntry;
class TextMessage;
class PermissionDenied;
class ACL;
class ACL_ChanGroup;
class ACL_ChanACL;
class QueryUsers;
class CryptSetup;
class ContextActionAdd;
class ContextAction;
class UserList;
class UserList_User;
class VoiceTarget;
class VoiceTarget_Target;
class PermissionQuery;
class CodecVersion;

enum Reject_RejectType {
  Reject_RejectType_None = 0,
  Reject_RejectType_WrongVersion = 1,
  Reject_RejectType_InvalidUsername = 2,
  Reject_RejectType_WrongUserPW = 3,
  Reject_RejectType_WrongServerPW = 4,
  Reject_RejectType_UsernameInUse = 5,
  Reject_RejectType_ServerFull = 6,
  Reject_RejectType_NoCertificate = 7
};
bool Reject_RejectType_IsValid(int value);
const Reject_RejectType Reject_RejectType_RejectType_MIN = Reject_RejectType_None;
const Reject_RejectType Reject_RejectType_RejectType_MAX = Reject_RejectType_NoCertificate;
const int Reject_RejectType_RejectType_ARRAYSIZE = Reject_RejectType_RejectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reject_RejectType_descriptor();
inline const ::std::string& Reject_RejectType_Name(Reject_RejectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reject_RejectType_descriptor(), value);
}
inline bool Reject_RejectType_Parse(
    const ::std::string& name, Reject_RejectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reject_RejectType>(
    Reject_RejectType_descriptor(), name, value);
}
enum PermissionDenied_DenyType {
  PermissionDenied_DenyType_Text = 0,
  PermissionDenied_DenyType_Permission = 1,
  PermissionDenied_DenyType_SuperUser = 2,
  PermissionDenied_DenyType_ChannelName = 3,
  PermissionDenied_DenyType_TextTooLong = 4,
  PermissionDenied_DenyType_H9K = 5,
  PermissionDenied_DenyType_TemporaryChannel = 6,
  PermissionDenied_DenyType_MissingCertificate = 7,
  PermissionDenied_DenyType_UserName = 8,
  PermissionDenied_DenyType_ChannelFull = 9
};
bool PermissionDenied_DenyType_IsValid(int value);
const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MIN = PermissionDenied_DenyType_Text;
const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MAX = PermissionDenied_DenyType_ChannelFull;
const int PermissionDenied_DenyType_DenyType_ARRAYSIZE = PermissionDenied_DenyType_DenyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PermissionDenied_DenyType_descriptor();
inline const ::std::string& PermissionDenied_DenyType_Name(PermissionDenied_DenyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PermissionDenied_DenyType_descriptor(), value);
}
inline bool PermissionDenied_DenyType_Parse(
    const ::std::string& name, PermissionDenied_DenyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PermissionDenied_DenyType>(
    PermissionDenied_DenyType_descriptor(), name, value);
}
enum ContextActionAdd_Context {
  ContextActionAdd_Context_Server = 1,
  ContextActionAdd_Context_Channel = 2,
  ContextActionAdd_Context_User = 4
};
bool ContextActionAdd_Context_IsValid(int value);
const ContextActionAdd_Context ContextActionAdd_Context_Context_MIN = ContextActionAdd_Context_Server;
const ContextActionAdd_Context ContextActionAdd_Context_Context_MAX = ContextActionAdd_Context_User;
const int ContextActionAdd_Context_Context_ARRAYSIZE = ContextActionAdd_Context_Context_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContextActionAdd_Context_descriptor();
inline const ::std::string& ContextActionAdd_Context_Name(ContextActionAdd_Context value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContextActionAdd_Context_descriptor(), value);
}
inline bool ContextActionAdd_Context_Parse(
    const ::std::string& name, ContextActionAdd_Context* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextActionAdd_Context>(
    ContextActionAdd_Context_descriptor(), name, value);
}
// ===================================================================

class Version : public ::google::protobuf::Message {
 public:
  Version();
  virtual ~Version();
  
  Version(const Version& from);
  
  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();
  
  void Swap(Version* other);
  
  // implements Message ----------------------------------------------
  
  Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // optional string release = 2;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 2;
  inline const ::std::string& release() const;
  inline void set_release(const ::std::string& value);
  inline void set_release(const char* value);
  inline void set_release(const char* value, size_t size);
  inline ::std::string* mutable_release();
  
  // optional string os = 3;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 3;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  
  // optional string os_version = 4;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 4;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const char* value, size_t size);
  inline ::std::string* mutable_os_version();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.Version)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 version_;
  ::std::string* release_;
  static const ::std::string _default_release_;
  ::std::string* os_;
  static const ::std::string _default_os_;
  ::std::string* os_version_;
  static const ::std::string _default_os_version_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Version* default_instance_;
};
// -------------------------------------------------------------------

class UDPTunnel : public ::google::protobuf::Message {
 public:
  UDPTunnel();
  virtual ~UDPTunnel();
  
  UDPTunnel(const UDPTunnel& from);
  
  inline UDPTunnel& operator=(const UDPTunnel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UDPTunnel& default_instance();
  
  void Swap(UDPTunnel* other);
  
  // implements Message ----------------------------------------------
  
  UDPTunnel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UDPTunnel& from);
  void MergeFrom(const UDPTunnel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes packet = 1;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 1;
  inline const ::std::string& packet() const;
  inline void set_packet(const ::std::string& value);
  inline void set_packet(const char* value);
  inline void set_packet(const void* value, size_t size);
  inline ::std::string* mutable_packet();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.UDPTunnel)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* packet_;
  static const ::std::string _default_packet_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UDPTunnel* default_instance_;
};
// -------------------------------------------------------------------

class Authenticate : public ::google::protobuf::Message {
 public:
  Authenticate();
  virtual ~Authenticate();
  
  Authenticate(const Authenticate& from);
  
  inline Authenticate& operator=(const Authenticate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Authenticate& default_instance();
  
  void Swap(Authenticate* other);
  
  // implements Message ----------------------------------------------
  
  Authenticate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Authenticate& from);
  void MergeFrom(const Authenticate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  
  // repeated string tokens = 3;
  inline int tokens_size() const;
  inline void clear_tokens();
  static const int kTokensFieldNumber = 3;
  inline const ::std::string& tokens(int index) const;
  inline ::std::string* mutable_tokens(int index);
  inline void set_tokens(int index, const ::std::string& value);
  inline void set_tokens(int index, const char* value);
  inline void set_tokens(int index, const char* value, size_t size);
  inline ::std::string* add_tokens();
  inline void add_tokens(const ::std::string& value);
  inline void add_tokens(const char* value);
  inline void add_tokens(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();
  
  // repeated int32 celt_versions = 4;
  inline int celt_versions_size() const;
  inline void clear_celt_versions();
  static const int kCeltVersionsFieldNumber = 4;
  inline ::google::protobuf::int32 celt_versions(int index) const;
  inline void set_celt_versions(int index, ::google::protobuf::int32 value);
  inline void add_celt_versions(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      celt_versions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_celt_versions();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.Authenticate)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* username_;
  static const ::std::string _default_username_;
  ::std::string* password_;
  static const ::std::string _default_password_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > celt_versions_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Authenticate* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();
  
  Ping(const Ping& from);
  
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();
  
  void Swap(Ping* other);
  
  // implements Message ----------------------------------------------
  
  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // optional uint32 good = 2;
  inline bool has_good() const;
  inline void clear_good();
  static const int kGoodFieldNumber = 2;
  inline ::google::protobuf::uint32 good() const;
  inline void set_good(::google::protobuf::uint32 value);
  
  // optional uint32 late = 3;
  inline bool has_late() const;
  inline void clear_late();
  static const int kLateFieldNumber = 3;
  inline ::google::protobuf::uint32 late() const;
  inline void set_late(::google::protobuf::uint32 value);
  
  // optional uint32 lost = 4;
  inline bool has_lost() const;
  inline void clear_lost();
  static const int kLostFieldNumber = 4;
  inline ::google::protobuf::uint32 lost() const;
  inline void set_lost(::google::protobuf::uint32 value);
  
  // optional uint32 resync = 5;
  inline bool has_resync() const;
  inline void clear_resync();
  static const int kResyncFieldNumber = 5;
  inline ::google::protobuf::uint32 resync() const;
  inline void set_resync(::google::protobuf::uint32 value);
  
  // optional uint32 udp_packets = 6;
  inline bool has_udp_packets() const;
  inline void clear_udp_packets();
  static const int kUdpPacketsFieldNumber = 6;
  inline ::google::protobuf::uint32 udp_packets() const;
  inline void set_udp_packets(::google::protobuf::uint32 value);
  
  // optional uint32 tcp_packets = 7;
  inline bool has_tcp_packets() const;
  inline void clear_tcp_packets();
  static const int kTcpPacketsFieldNumber = 7;
  inline ::google::protobuf::uint32 tcp_packets() const;
  inline void set_tcp_packets(::google::protobuf::uint32 value);
  
  // optional float udp_ping_avg = 8;
  inline bool has_udp_ping_avg() const;
  inline void clear_udp_ping_avg();
  static const int kUdpPingAvgFieldNumber = 8;
  inline float udp_ping_avg() const;
  inline void set_udp_ping_avg(float value);
  
  // optional float udp_ping_var = 9;
  inline bool has_udp_ping_var() const;
  inline void clear_udp_ping_var();
  static const int kUdpPingVarFieldNumber = 9;
  inline float udp_ping_var() const;
  inline void set_udp_ping_var(float value);
  
  // optional float tcp_ping_avg = 10;
  inline bool has_tcp_ping_avg() const;
  inline void clear_tcp_ping_avg();
  static const int kTcpPingAvgFieldNumber = 10;
  inline float tcp_ping_avg() const;
  inline void set_tcp_ping_avg(float value);
  
  // optional float tcp_ping_var = 11;
  inline bool has_tcp_ping_var() const;
  inline void clear_tcp_ping_var();
  static const int kTcpPingVarFieldNumber = 11;
  inline float tcp_ping_var() const;
  inline void set_tcp_ping_var(float value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.Ping)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 good_;
  ::google::protobuf::uint32 late_;
  ::google::protobuf::uint32 lost_;
  ::google::protobuf::uint32 resync_;
  ::google::protobuf::uint32 udp_packets_;
  ::google::protobuf::uint32 tcp_packets_;
  float udp_ping_avg_;
  float udp_ping_var_;
  float tcp_ping_avg_;
  float tcp_ping_var_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Reject : public ::google::protobuf::Message {
 public:
  Reject();
  virtual ~Reject();
  
  Reject(const Reject& from);
  
  inline Reject& operator=(const Reject& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reject& default_instance();
  
  void Swap(Reject* other);
  
  // implements Message ----------------------------------------------
  
  Reject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reject& from);
  void MergeFrom(const Reject& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Reject_RejectType RejectType;
  static const RejectType None = Reject_RejectType_None;
  static const RejectType WrongVersion = Reject_RejectType_WrongVersion;
  static const RejectType InvalidUsername = Reject_RejectType_InvalidUsername;
  static const RejectType WrongUserPW = Reject_RejectType_WrongUserPW;
  static const RejectType WrongServerPW = Reject_RejectType_WrongServerPW;
  static const RejectType UsernameInUse = Reject_RejectType_UsernameInUse;
  static const RejectType ServerFull = Reject_RejectType_ServerFull;
  static const RejectType NoCertificate = Reject_RejectType_NoCertificate;
  static inline bool RejectType_IsValid(int value) {
    return Reject_RejectType_IsValid(value);
  }
  static const RejectType RejectType_MIN =
    Reject_RejectType_RejectType_MIN;
  static const RejectType RejectType_MAX =
    Reject_RejectType_RejectType_MAX;
  static const int RejectType_ARRAYSIZE =
    Reject_RejectType_RejectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RejectType_descriptor() {
    return Reject_RejectType_descriptor();
  }
  static inline const ::std::string& RejectType_Name(RejectType value) {
    return Reject_RejectType_Name(value);
  }
  static inline bool RejectType_Parse(const ::std::string& name,
      RejectType* value) {
    return Reject_RejectType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MumbleProto.Reject.RejectType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MumbleProto::Reject_RejectType type() const;
  inline void set_type(::MumbleProto::Reject_RejectType value);
  
  // optional string reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.Reject)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Reject* default_instance_;
};
// -------------------------------------------------------------------

class ServerSync : public ::google::protobuf::Message {
 public:
  ServerSync();
  virtual ~ServerSync();
  
  ServerSync(const ServerSync& from);
  
  inline ServerSync& operator=(const ServerSync& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerSync& default_instance();
  
  void Swap(ServerSync* other);
  
  // implements Message ----------------------------------------------
  
  ServerSync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerSync& from);
  void MergeFrom(const ServerSync& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);
  
  // optional uint32 max_bandwidth = 2;
  inline bool has_max_bandwidth() const;
  inline void clear_max_bandwidth();
  static const int kMaxBandwidthFieldNumber = 2;
  inline ::google::protobuf::uint32 max_bandwidth() const;
  inline void set_max_bandwidth(::google::protobuf::uint32 value);
  
  // optional string welcome_text = 3;
  inline bool has_welcome_text() const;
  inline void clear_welcome_text();
  static const int kWelcomeTextFieldNumber = 3;
  inline const ::std::string& welcome_text() const;
  inline void set_welcome_text(const ::std::string& value);
  inline void set_welcome_text(const char* value);
  inline void set_welcome_text(const char* value, size_t size);
  inline ::std::string* mutable_welcome_text();
  
  // optional uint64 permissions = 4;
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 4;
  inline ::google::protobuf::uint64 permissions() const;
  inline void set_permissions(::google::protobuf::uint64 value);
  
  // optional bool allow_html = 5 [default = true];
  inline bool has_allow_html() const;
  inline void clear_allow_html();
  static const int kAllowHtmlFieldNumber = 5;
  inline bool allow_html() const;
  inline void set_allow_html(bool value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ServerSync)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 max_bandwidth_;
  ::std::string* welcome_text_;
  static const ::std::string _default_welcome_text_;
  ::google::protobuf::uint64 permissions_;
  bool allow_html_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ServerSync* default_instance_;
};
// -------------------------------------------------------------------

class ChannelRemove : public ::google::protobuf::Message {
 public:
  ChannelRemove();
  virtual ~ChannelRemove();
  
  ChannelRemove(const ChannelRemove& from);
  
  inline ChannelRemove& operator=(const ChannelRemove& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelRemove& default_instance();
  
  void Swap(ChannelRemove* other);
  
  // implements Message ----------------------------------------------
  
  ChannelRemove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelRemove& from);
  void MergeFrom(const ChannelRemove& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelRemove)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 channel_id_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ChannelRemove* default_instance_;
};
// -------------------------------------------------------------------

class ChannelState : public ::google::protobuf::Message {
 public:
  ChannelState();
  virtual ~ChannelState();
  
  ChannelState(const ChannelState& from);
  
  inline ChannelState& operator=(const ChannelState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelState& default_instance();
  
  void Swap(ChannelState* other);
  
  // implements Message ----------------------------------------------
  
  ChannelState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelState& from);
  void MergeFrom(const ChannelState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // optional uint32 parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline ::google::protobuf::uint32 parent() const;
  inline void set_parent(::google::protobuf::uint32 value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated uint32 links = 4;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 4;
  inline ::google::protobuf::uint32 links(int index) const;
  inline void set_links(int index, ::google::protobuf::uint32 value);
  inline void add_links(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links();
  
  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  
  // repeated uint32 links_add = 6;
  inline int links_add_size() const;
  inline void clear_links_add();
  static const int kLinksAddFieldNumber = 6;
  inline ::google::protobuf::uint32 links_add(int index) const;
  inline void set_links_add(int index, ::google::protobuf::uint32 value);
  inline void add_links_add(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links_add() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links_add();
  
  // repeated uint32 links_remove = 7;
  inline int links_remove_size() const;
  inline void clear_links_remove();
  static const int kLinksRemoveFieldNumber = 7;
  inline ::google::protobuf::uint32 links_remove(int index) const;
  inline void set_links_remove(int index, ::google::protobuf::uint32 value);
  inline void add_links_remove(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links_remove() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links_remove();
  
  // optional bool temporary = 8 [default = false];
  inline bool has_temporary() const;
  inline void clear_temporary();
  static const int kTemporaryFieldNumber = 8;
  inline bool temporary() const;
  inline void set_temporary(bool value);
  
  // optional int32 position = 9 [default = 0];
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 9;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelState)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 parent_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_;
  ::std::string* description_;
  static const ::std::string _default_description_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_add_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_remove_;
  bool temporary_;
  ::google::protobuf::int32 position_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ChannelState* default_instance_;
};
// -------------------------------------------------------------------

class UserRemove : public ::google::protobuf::Message {
 public:
  UserRemove();
  virtual ~UserRemove();
  
  UserRemove(const UserRemove& from);
  
  inline UserRemove& operator=(const UserRemove& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRemove& default_instance();
  
  void Swap(UserRemove* other);
  
  // implements Message ----------------------------------------------
  
  UserRemove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserRemove& from);
  void MergeFrom(const UserRemove& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);
  
  // optional uint32 actor = 2;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 2;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);
  
  // optional string reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  
  // optional bool ban = 4;
  inline bool has_ban() const;
  inline void clear_ban();
  static const int kBanFieldNumber = 4;
  inline bool ban() const;
  inline void set_ban(bool value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.UserRemove)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 actor_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  bool ban_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserRemove* default_instance_;
};
// -------------------------------------------------------------------

class UserState : public ::google::protobuf::Message {
 public:
  UserState();
  virtual ~UserState();
  
  UserState(const UserState& from);
  
  inline UserState& operator=(const UserState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserState& default_instance();
  
  void Swap(UserState* other);
  
  // implements Message ----------------------------------------------
  
  UserState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserState& from);
  void MergeFrom(const UserState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);
  
  // optional uint32 actor = 2;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 2;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional uint32 user_id = 4;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // optional uint32 channel_id = 5;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 5;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // optional bool mute = 6;
  inline bool has_mute() const;
  inline void clear_mute();
  static const int kMuteFieldNumber = 6;
  inline bool mute() const;
  inline void set_mute(bool value);
  
  // optional bool deaf = 7;
  inline bool has_deaf() const;
  inline void clear_deaf();
  static const int kDeafFieldNumber = 7;
  inline bool deaf() const;
  inline void set_deaf(bool value);
  
  // optional bool suppress = 8;
  inline bool has_suppress() const;
  inline void clear_suppress();
  static const int kSuppressFieldNumber = 8;
  inline bool suppress() const;
  inline void set_suppress(bool value);
  
  // optional bool self_mute = 9;
  inline bool has_self_mute() const;
  inline void clear_self_mute();
  static const int kSelfMuteFieldNumber = 9;
  inline bool self_mute() const;
  inline void set_self_mute(bool value);
  
  // optional bool self_deaf = 10;
  inline bool has_self_deaf() const;
  inline void clear_self_deaf();
  static const int kSelfDeafFieldNumber = 10;
  inline bool self_deaf() const;
  inline void set_self_deaf(bool value);
  
  // optional bytes texture = 11;
  inline bool has_texture() const;
  inline void clear_texture();
  static const int kTextureFieldNumber = 11;
  inline const ::std::string& texture() const;
  inline void set_texture(const ::std::string& value);
  inline void set_texture(const char* value);
  inline void set_texture(const void* value, size_t size);
  inline ::std::string* mutable_texture();
  
  // optional string plugin_context = 12;
  inline bool has_plugin_context() const;
  inline void clear_plugin_context();
  static const int kPluginContextFieldNumber = 12;
  inline const ::std::string& plugin_context() const;
  inline void set_plugin_context(const ::std::string& value);
  inline void set_plugin_context(const char* value);
  inline void set_plugin_context(const char* value, size_t size);
  inline ::std::string* mutable_plugin_context();
  
  // optional string plugin_identity = 13;
  inline bool has_plugin_identity() const;
  inline void clear_plugin_identity();
  static const int kPluginIdentityFieldNumber = 13;
  inline const ::std::string& plugin_identity() const;
  inline void set_plugin_identity(const ::std::string& value);
  inline void set_plugin_identity(const char* value);
  inline void set_plugin_identity(const char* value, size_t size);
  inline ::std::string* mutable_plugin_identity();
  
  // optional string comment = 14;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 14;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  
  // optional string hash = 15;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 15;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.UserState)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 actor_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 channel_id_;
  bool mute_;
  bool deaf_;
  bool suppress_;
  bool self_mute_;
  bool self_deaf_;
  ::std::string* texture_;
  static const ::std::string _default_texture_;
  ::std::string* plugin_context_;
  static const ::std::string _default_plugin_context_;
  ::std::string* plugin_identity_;
  static const ::std::string _default_plugin_identity_;
  ::std::string* comment_;
  static const ::std::string _default_comment_;
  ::std::string* hash_;
  static const ::std::string _default_hash_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserState* default_instance_;
};
// -------------------------------------------------------------------

class BanList_BanEntry : public ::google::protobuf::Message {
 public:
  BanList_BanEntry();
  virtual ~BanList_BanEntry();
  
  BanList_BanEntry(const BanList_BanEntry& from);
  
  inline BanList_BanEntry& operator=(const BanList_BanEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BanList_BanEntry& default_instance();
  
  void Swap(BanList_BanEntry* other);
  
  // implements Message ----------------------------------------------
  
  BanList_BanEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BanList_BanEntry& from);
  void MergeFrom(const BanList_BanEntry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  
  // required uint32 mask = 2;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 2;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string hash = 4;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 4;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  
  // optional string reason = 5;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 5;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  
  // optional string start = 6;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 6;
  inline const ::std::string& start() const;
  inline void set_start(const ::std::string& value);
  inline void set_start(const char* value);
  inline void set_start(const char* value, size_t size);
  inline ::std::string* mutable_start();
  
  // optional uint32 duration = 7;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 7;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.BanList.BanEntry)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* address_;
  static const ::std::string _default_address_;
  ::google::protobuf::uint32 mask_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* hash_;
  static const ::std::string _default_hash_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  ::std::string* start_;
  static const ::std::string _default_start_;
  ::google::protobuf::uint32 duration_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BanList_BanEntry* default_instance_;
};
// -------------------------------------------------------------------

class BanList : public ::google::protobuf::Message {
 public:
  BanList();
  virtual ~BanList();
  
  BanList(const BanList& from);
  
  inline BanList& operator=(const BanList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BanList& default_instance();
  
  void Swap(BanList* other);
  
  // implements Message ----------------------------------------------
  
  BanList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BanList& from);
  void MergeFrom(const BanList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BanList_BanEntry BanEntry;
  
  // accessors -------------------------------------------------------
  
  // repeated .MumbleProto.BanList.BanEntry bans = 1;
  inline int bans_size() const;
  inline void clear_bans();
  static const int kBansFieldNumber = 1;
  inline const ::MumbleProto::BanList_BanEntry& bans(int index) const;
  inline ::MumbleProto::BanList_BanEntry* mutable_bans(int index);
  inline ::MumbleProto::BanList_BanEntry* add_bans();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
      bans() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
      mutable_bans();
  
  // optional bool query = 2 [default = false];
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline bool query() const;
  inline void set_query(bool value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.BanList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry > bans_;
  bool query_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BanList* default_instance_;
};
// -------------------------------------------------------------------

class TextMessage : public ::google::protobuf::Message {
 public:
  TextMessage();
  virtual ~TextMessage();
  
  TextMessage(const TextMessage& from);
  
  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TextMessage& default_instance();
  
  void Swap(TextMessage* other);
  
  // implements Message ----------------------------------------------
  
  TextMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextMessage& from);
  void MergeFrom(const TextMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 actor = 1;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 1;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);
  
  // repeated uint32 session = 2;
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline ::google::protobuf::uint32 session(int index) const;
  inline void set_session(int index, ::google::protobuf::uint32 value);
  inline void add_session(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session();
  
  // repeated uint32 channel_id = 3;
  inline int channel_id_size() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 3;
  inline ::google::protobuf::uint32 channel_id(int index) const;
  inline void set_channel_id(int index, ::google::protobuf::uint32 value);
  inline void add_channel_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channel_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channel_id();
  
  // repeated uint32 tree_id = 4;
  inline int tree_id_size() const;
  inline void clear_tree_id();
  static const int kTreeIdFieldNumber = 4;
  inline ::google::protobuf::uint32 tree_id(int index) const;
  inline void set_tree_id(int index, ::google::protobuf::uint32 value);
  inline void add_tree_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tree_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tree_id();
  
  // required string message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.TextMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 actor_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tree_id_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TextMessage* default_instance_;
};
// -------------------------------------------------------------------

class PermissionDenied : public ::google::protobuf::Message {
 public:
  PermissionDenied();
  virtual ~PermissionDenied();
  
  PermissionDenied(const PermissionDenied& from);
  
  inline PermissionDenied& operator=(const PermissionDenied& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PermissionDenied& default_instance();
  
  void Swap(PermissionDenied* other);
  
  // implements Message ----------------------------------------------
  
  PermissionDenied* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PermissionDenied& from);
  void MergeFrom(const PermissionDenied& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PermissionDenied_DenyType DenyType;
  static const DenyType Text = PermissionDenied_DenyType_Text;
  static const DenyType Permission = PermissionDenied_DenyType_Permission;
  static const DenyType SuperUser = PermissionDenied_DenyType_SuperUser;
  static const DenyType ChannelName = PermissionDenied_DenyType_ChannelName;
  static const DenyType TextTooLong = PermissionDenied_DenyType_TextTooLong;
  static const DenyType H9K = PermissionDenied_DenyType_H9K;
  static const DenyType TemporaryChannel = PermissionDenied_DenyType_TemporaryChannel;
  static const DenyType MissingCertificate = PermissionDenied_DenyType_MissingCertificate;
  static const DenyType UserName = PermissionDenied_DenyType_UserName;
  static const DenyType ChannelFull = PermissionDenied_DenyType_ChannelFull;
  static inline bool DenyType_IsValid(int value) {
    return PermissionDenied_DenyType_IsValid(value);
  }
  static const DenyType DenyType_MIN =
    PermissionDenied_DenyType_DenyType_MIN;
  static const DenyType DenyType_MAX =
    PermissionDenied_DenyType_DenyType_MAX;
  static const int DenyType_ARRAYSIZE =
    PermissionDenied_DenyType_DenyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DenyType_descriptor() {
    return PermissionDenied_DenyType_descriptor();
  }
  static inline const ::std::string& DenyType_Name(DenyType value) {
    return PermissionDenied_DenyType_Name(value);
  }
  static inline bool DenyType_Parse(const ::std::string& name,
      DenyType* value) {
    return PermissionDenied_DenyType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional uint32 permission = 1;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 1;
  inline ::google::protobuf::uint32 permission() const;
  inline void set_permission(::google::protobuf::uint32 value);
  
  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // optional uint32 session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);
  
  // optional string reason = 4;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 4;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  
  // optional .MumbleProto.PermissionDenied.DenyType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::MumbleProto::PermissionDenied_DenyType type() const;
  inline void set_type(::MumbleProto::PermissionDenied_DenyType value);
  
  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionDenied)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 permission_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 session_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  int type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PermissionDenied* default_instance_;
};
// -------------------------------------------------------------------

class ACL_ChanGroup : public ::google::protobuf::Message {
 public:
  ACL_ChanGroup();
  virtual ~ACL_ChanGroup();
  
  ACL_ChanGroup(const ACL_ChanGroup& from);
  
  inline ACL_ChanGroup& operator=(const ACL_ChanGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ChanGroup& default_instance();
  
  void Swap(ACL_ChanGroup* other);
  
  // implements Message ----------------------------------------------
  
  ACL_ChanGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_ChanGroup& from);
  void MergeFrom(const ACL_ChanGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional bool inherited = 2 [default = true];
  inline bool has_inherited() const;
  inline void clear_inherited();
  static const int kInheritedFieldNumber = 2;
  inline bool inherited() const;
  inline void set_inherited(bool value);
  
  // optional bool inherit = 3 [default = true];
  inline bool has_inherit() const;
  inline void clear_inherit();
  static const int kInheritFieldNumber = 3;
  inline bool inherit() const;
  inline void set_inherit(bool value);
  
  // optional bool inheritable = 4 [default = true];
  inline bool has_inheritable() const;
  inline void clear_inheritable();
  static const int kInheritableFieldNumber = 4;
  inline bool inheritable() const;
  inline void set_inheritable(bool value);
  
  // repeated uint32 add = 5;
  inline int add_size() const;
  inline void clear_add();
  static const int kAddFieldNumber = 5;
  inline ::google::protobuf::uint32 add(int index) const;
  inline void set_add(int index, ::google::protobuf::uint32 value);
  inline void add_add(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      add() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_add();
  
  // repeated uint32 remove = 6;
  inline int remove_size() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 6;
  inline ::google::protobuf::uint32 remove(int index) const;
  inline void set_remove(int index, ::google::protobuf::uint32 value);
  inline void add_remove(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      remove() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_remove();
  
  // repeated uint32 inherited_members = 7;
  inline int inherited_members_size() const;
  inline void clear_inherited_members();
  static const int kInheritedMembersFieldNumber = 7;
  inline ::google::protobuf::uint32 inherited_members(int index) const;
  inline void set_inherited_members(int index, ::google::protobuf::uint32 value);
  inline void add_inherited_members(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      inherited_members() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_inherited_members();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanGroup)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  bool inherited_;
  bool inherit_;
  bool inheritable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > add_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > remove_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > inherited_members_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ACL_ChanGroup* default_instance_;
};
// -------------------------------------------------------------------

class ACL_ChanACL : public ::google::protobuf::Message {
 public:
  ACL_ChanACL();
  virtual ~ACL_ChanACL();
  
  ACL_ChanACL(const ACL_ChanACL& from);
  
  inline ACL_ChanACL& operator=(const ACL_ChanACL& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ChanACL& default_instance();
  
  void Swap(ACL_ChanACL* other);
  
  // implements Message ----------------------------------------------
  
  ACL_ChanACL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_ChanACL& from);
  void MergeFrom(const ACL_ChanACL& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool apply_here = 1 [default = true];
  inline bool has_apply_here() const;
  inline void clear_apply_here();
  static const int kApplyHereFieldNumber = 1;
  inline bool apply_here() const;
  inline void set_apply_here(bool value);
  
  // optional bool apply_subs = 2 [default = true];
  inline bool has_apply_subs() const;
  inline void clear_apply_subs();
  static const int kApplySubsFieldNumber = 2;
  inline bool apply_subs() const;
  inline void set_apply_subs(bool value);
  
  // optional bool inherited = 3 [default = true];
  inline bool has_inherited() const;
  inline void clear_inherited();
  static const int kInheritedFieldNumber = 3;
  inline bool inherited() const;
  inline void set_inherited(bool value);
  
  // optional uint32 user_id = 4;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // optional string group = 5;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 5;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  
  // optional uint32 grant = 6;
  inline bool has_grant() const;
  inline void clear_grant();
  static const int kGrantFieldNumber = 6;
  inline ::google::protobuf::uint32 grant() const;
  inline void set_grant(::google::protobuf::uint32 value);
  
  // optional uint32 deny = 7;
  inline bool has_deny() const;
  inline void clear_deny();
  static const int kDenyFieldNumber = 7;
  inline ::google::protobuf::uint32 deny() const;
  inline void set_deny(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanACL)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool apply_here_;
  bool apply_subs_;
  bool inherited_;
  ::google::protobuf::uint32 user_id_;
  ::std::string* group_;
  static const ::std::string _default_group_;
  ::google::protobuf::uint32 grant_;
  ::google::protobuf::uint32 deny_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ACL_ChanACL* default_instance_;
};
// -------------------------------------------------------------------

class ACL : public ::google::protobuf::Message {
 public:
  ACL();
  virtual ~ACL();
  
  ACL(const ACL& from);
  
  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL& default_instance();
  
  void Swap(ACL* other);
  
  // implements Message ----------------------------------------------
  
  ACL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ACL_ChanGroup ChanGroup;
  typedef ACL_ChanACL ChanACL;
  
  // accessors -------------------------------------------------------
  
  // required uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // optional bool inherit_acls = 2 [default = true];
  inline bool has_inherit_acls() const;
  inline void clear_inherit_acls();
  static const int kInheritAclsFieldNumber = 2;
  inline bool inherit_acls() const;
  inline void set_inherit_acls(bool value);
  
  // repeated .MumbleProto.ACL.ChanGroup groups = 3;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 3;
  inline const ::MumbleProto::ACL_ChanGroup& groups(int index) const;
  inline ::MumbleProto::ACL_ChanGroup* mutable_groups(int index);
  inline ::MumbleProto::ACL_ChanGroup* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
      mutable_groups();
  
  // repeated .MumbleProto.ACL.ChanACL acls = 4;
  inline int acls_size() const;
  inline void clear_acls();
  static const int kAclsFieldNumber = 4;
  inline const ::MumbleProto::ACL_ChanACL& acls(int index) const;
  inline ::MumbleProto::ACL_ChanACL* mutable_acls(int index);
  inline ::MumbleProto::ACL_ChanACL* add_acls();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
      acls() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
      mutable_acls();
  
  // optional bool query = 5 [default = false];
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 5;
  inline bool query() const;
  inline void set_query(bool value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ACL)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 channel_id_;
  bool inherit_acls_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup > groups_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL > acls_;
  bool query_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ACL* default_instance_;
};
// -------------------------------------------------------------------

class QueryUsers : public ::google::protobuf::Message {
 public:
  QueryUsers();
  virtual ~QueryUsers();
  
  QueryUsers(const QueryUsers& from);
  
  inline QueryUsers& operator=(const QueryUsers& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryUsers& default_instance();
  
  void Swap(QueryUsers* other);
  
  // implements Message ----------------------------------------------
  
  QueryUsers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryUsers& from);
  void MergeFrom(const QueryUsers& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 ids = 1;
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 ids(int index) const;
  inline void set_ids(int index, ::google::protobuf::uint32 value);
  inline void add_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ids();
  
  // repeated string names = 2;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 2;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.QueryUsers)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static QueryUsers* default_instance_;
};
// -------------------------------------------------------------------

class CryptSetup : public ::google::protobuf::Message {
 public:
  CryptSetup();
  virtual ~CryptSetup();
  
  CryptSetup(const CryptSetup& from);
  
  inline CryptSetup& operator=(const CryptSetup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CryptSetup& default_instance();
  
  void Swap(CryptSetup* other);
  
  // implements Message ----------------------------------------------
  
  CryptSetup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CryptSetup& from);
  void MergeFrom(const CryptSetup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional bytes client_nonce = 2;
  inline bool has_client_nonce() const;
  inline void clear_client_nonce();
  static const int kClientNonceFieldNumber = 2;
  inline const ::std::string& client_nonce() const;
  inline void set_client_nonce(const ::std::string& value);
  inline void set_client_nonce(const char* value);
  inline void set_client_nonce(const void* value, size_t size);
  inline ::std::string* mutable_client_nonce();
  
  // optional bytes server_nonce = 3;
  inline bool has_server_nonce() const;
  inline void clear_server_nonce();
  static const int kServerNonceFieldNumber = 3;
  inline const ::std::string& server_nonce() const;
  inline void set_server_nonce(const ::std::string& value);
  inline void set_server_nonce(const char* value);
  inline void set_server_nonce(const void* value, size_t size);
  inline ::std::string* mutable_server_nonce();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.CryptSetup)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* client_nonce_;
  static const ::std::string _default_client_nonce_;
  ::std::string* server_nonce_;
  static const ::std::string _default_server_nonce_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CryptSetup* default_instance_;
};
// -------------------------------------------------------------------

class ContextActionAdd : public ::google::protobuf::Message {
 public:
  ContextActionAdd();
  virtual ~ContextActionAdd();
  
  ContextActionAdd(const ContextActionAdd& from);
  
  inline ContextActionAdd& operator=(const ContextActionAdd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContextActionAdd& default_instance();
  
  void Swap(ContextActionAdd* other);
  
  // implements Message ----------------------------------------------
  
  ContextActionAdd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContextActionAdd& from);
  void MergeFrom(const ContextActionAdd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ContextActionAdd_Context Context;
  static const Context Server = ContextActionAdd_Context_Server;
  static const Context Channel = ContextActionAdd_Context_Channel;
  static const Context User = ContextActionAdd_Context_User;
  static inline bool Context_IsValid(int value) {
    return ContextActionAdd_Context_IsValid(value);
  }
  static const Context Context_MIN =
    ContextActionAdd_Context_Context_MIN;
  static const Context Context_MAX =
    ContextActionAdd_Context_Context_MAX;
  static const int Context_ARRAYSIZE =
    ContextActionAdd_Context_Context_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Context_descriptor() {
    return ContextActionAdd_Context_descriptor();
  }
  static inline const ::std::string& Context_Name(Context value) {
    return ContextActionAdd_Context_Name(value);
  }
  static inline bool Context_Parse(const ::std::string& name,
      Context* value) {
    return ContextActionAdd_Context_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  
  // required string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
  // optional uint32 context = 3;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 3;
  inline ::google::protobuf::uint32 context() const;
  inline void set_context(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ContextActionAdd)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_;
  static const ::std::string _default_action_;
  ::std::string* text_;
  static const ::std::string _default_text_;
  ::google::protobuf::uint32 context_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ContextActionAdd* default_instance_;
};
// -------------------------------------------------------------------

class ContextAction : public ::google::protobuf::Message {
 public:
  ContextAction();
  virtual ~ContextAction();
  
  ContextAction(const ContextAction& from);
  
  inline ContextAction& operator=(const ContextAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContextAction& default_instance();
  
  void Swap(ContextAction* other);
  
  // implements Message ----------------------------------------------
  
  ContextAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContextAction& from);
  void MergeFrom(const ContextAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);
  
  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // required string action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.ContextAction)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 channel_id_;
  ::std::string* action_;
  static const ::std::string _default_action_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ContextAction* default_instance_;
};
// -------------------------------------------------------------------

class UserList_User : public ::google::protobuf::Message {
 public:
  UserList_User();
  virtual ~UserList_User();
  
  UserList_User(const UserList_User& from);
  
  inline UserList_User& operator=(const UserList_User& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserList_User& default_instance();
  
  void Swap(UserList_User* other);
  
  // implements Message ----------------------------------------------
  
  UserList_User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserList_User& from);
  void MergeFrom(const UserList_User& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.UserList.User)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 user_id_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserList_User* default_instance_;
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::Message {
 public:
  UserList();
  virtual ~UserList();
  
  UserList(const UserList& from);
  
  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserList& default_instance();
  
  void Swap(UserList* other);
  
  // implements Message ----------------------------------------------
  
  UserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef UserList_User User;
  
  // accessors -------------------------------------------------------
  
  // repeated .MumbleProto.UserList.User users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::MumbleProto::UserList_User& users(int index) const;
  inline ::MumbleProto::UserList_User* mutable_users(int index);
  inline ::MumbleProto::UserList_User* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
      mutable_users();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.UserList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User > users_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserList* default_instance_;
};
// -------------------------------------------------------------------

class VoiceTarget_Target : public ::google::protobuf::Message {
 public:
  VoiceTarget_Target();
  virtual ~VoiceTarget_Target();
  
  VoiceTarget_Target(const VoiceTarget_Target& from);
  
  inline VoiceTarget_Target& operator=(const VoiceTarget_Target& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VoiceTarget_Target& default_instance();
  
  void Swap(VoiceTarget_Target* other);
  
  // implements Message ----------------------------------------------
  
  VoiceTarget_Target* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoiceTarget_Target& from);
  void MergeFrom(const VoiceTarget_Target& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 session = 1;
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session(int index) const;
  inline void set_session(int index, ::google::protobuf::uint32 value);
  inline void add_session(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session();
  
  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // optional string group = 3;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 3;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  
  // optional bool links = 4 [default = false];
  inline bool has_links() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 4;
  inline bool links() const;
  inline void set_links(bool value);
  
  // optional bool children = 5 [default = false];
  inline bool has_children() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 5;
  inline bool children() const;
  inline void set_children(bool value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget.Target)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
  ::google::protobuf::uint32 channel_id_;
  ::std::string* group_;
  static const ::std::string _default_group_;
  bool links_;
  bool children_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VoiceTarget_Target* default_instance_;
};
// -------------------------------------------------------------------

class VoiceTarget : public ::google::protobuf::Message {
 public:
  VoiceTarget();
  virtual ~VoiceTarget();
  
  VoiceTarget(const VoiceTarget& from);
  
  inline VoiceTarget& operator=(const VoiceTarget& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VoiceTarget& default_instance();
  
  void Swap(VoiceTarget* other);
  
  // implements Message ----------------------------------------------
  
  VoiceTarget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoiceTarget& from);
  void MergeFrom(const VoiceTarget& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VoiceTarget_Target Target;
  
  // accessors -------------------------------------------------------
  
  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // repeated .MumbleProto.VoiceTarget.Target targets = 2;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 2;
  inline const ::MumbleProto::VoiceTarget_Target& targets(int index) const;
  inline ::MumbleProto::VoiceTarget_Target* mutable_targets(int index);
  inline ::MumbleProto::VoiceTarget_Target* add_targets();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
      targets() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
      mutable_targets();
  
  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target > targets_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VoiceTarget* default_instance_;
};
// -------------------------------------------------------------------

class PermissionQuery : public ::google::protobuf::Message {
 public:
  PermissionQuery();
  virtual ~PermissionQuery();
  
  PermissionQuery(const PermissionQuery& from);
  
  inline PermissionQuery& operator=(const PermissionQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PermissionQuery& default_instance();
  
  void Swap(PermissionQuery* other);
  
  // implements Message ----------------------------------------------
  
  PermissionQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PermissionQuery& from);
  void MergeFrom(const PermissionQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);
  
  // optional uint32 permissions = 2;
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 2;
  inline ::google::protobuf::uint32 permissions() const;
  inline void set_permissions(::google::protobuf::uint32 value);
  
  // optional bool flush = 3 [default = false];
  inline bool has_flush() const;
  inline void clear_flush();
  static const int kFlushFieldNumber = 3;
  inline bool flush() const;
  inline void set_flush(bool value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionQuery)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 permissions_;
  bool flush_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PermissionQuery* default_instance_;
};
// -------------------------------------------------------------------

class CodecVersion : public ::google::protobuf::Message {
 public:
  CodecVersion();
  virtual ~CodecVersion();
  
  CodecVersion(const CodecVersion& from);
  
  inline CodecVersion& operator=(const CodecVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CodecVersion& default_instance();
  
  void Swap(CodecVersion* other);
  
  // implements Message ----------------------------------------------
  
  CodecVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CodecVersion& from);
  void MergeFrom(const CodecVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 alpha = 1;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  inline ::google::protobuf::int32 alpha() const;
  inline void set_alpha(::google::protobuf::int32 value);
  
  // required int32 beta = 2;
  inline bool has_beta() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 2;
  inline ::google::protobuf::int32 beta() const;
  inline void set_beta(::google::protobuf::int32 value);
  
  // required bool prefer_alpha = 3 [default = true];
  inline bool has_prefer_alpha() const;
  inline void clear_prefer_alpha();
  static const int kPreferAlphaFieldNumber = 3;
  inline bool prefer_alpha() const;
  inline void set_prefer_alpha(bool value);
  
  // @@protoc_insertion_point(class_scope:MumbleProto.CodecVersion)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 alpha_;
  ::google::protobuf::int32 beta_;
  bool prefer_alpha_;
  friend void  protobuf_AddDesc_Mumble_2eproto();
  friend void protobuf_AssignDesc_Mumble_2eproto();
  friend void protobuf_ShutdownFile_Mumble_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CodecVersion* default_instance_;
};
// ===================================================================


// ===================================================================

// Version

// optional uint32 version = 1;
inline bool Version::has_version() const {
  return _has_bit(0);
}
inline void Version::clear_version() {
  version_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 Version::version() const {
  return version_;
}
inline void Version::set_version(::google::protobuf::uint32 value) {
  _set_bit(0);
  version_ = value;
}

// optional string release = 2;
inline bool Version::has_release() const {
  return _has_bit(1);
}
inline void Version::clear_release() {
  if (release_ != &_default_release_) {
    release_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Version::release() const {
  return *release_;
}
inline void Version::set_release(const ::std::string& value) {
  _set_bit(1);
  if (release_ == &_default_release_) {
    release_ = new ::std::string;
  }
  release_->assign(value);
}
inline void Version::set_release(const char* value) {
  _set_bit(1);
  if (release_ == &_default_release_) {
    release_ = new ::std::string;
  }
  release_->assign(value);
}
inline void Version::set_release(const char* value, size_t size) {
  _set_bit(1);
  if (release_ == &_default_release_) {
    release_ = new ::std::string;
  }
  release_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_release() {
  _set_bit(1);
  if (release_ == &_default_release_) {
    release_ = new ::std::string;
  }
  return release_;
}

// optional string os = 3;
inline bool Version::has_os() const {
  return _has_bit(2);
}
inline void Version::clear_os() {
  if (os_ != &_default_os_) {
    os_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Version::os() const {
  return *os_;
}
inline void Version::set_os(const ::std::string& value) {
  _set_bit(2);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void Version::set_os(const char* value) {
  _set_bit(2);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void Version::set_os(const char* value, size_t size) {
  _set_bit(2);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_os() {
  _set_bit(2);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  return os_;
}

// optional string os_version = 4;
inline bool Version::has_os_version() const {
  return _has_bit(3);
}
inline void Version::clear_os_version() {
  if (os_version_ != &_default_os_version_) {
    os_version_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Version::os_version() const {
  return *os_version_;
}
inline void Version::set_os_version(const ::std::string& value) {
  _set_bit(3);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
}
inline void Version::set_os_version(const char* value) {
  _set_bit(3);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
}
inline void Version::set_os_version(const char* value, size_t size) {
  _set_bit(3);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_os_version() {
  _set_bit(3);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  return os_version_;
}

// -------------------------------------------------------------------

// UDPTunnel

// required bytes packet = 1;
inline bool UDPTunnel::has_packet() const {
  return _has_bit(0);
}
inline void UDPTunnel::clear_packet() {
  if (packet_ != &_default_packet_) {
    packet_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& UDPTunnel::packet() const {
  return *packet_;
}
inline void UDPTunnel::set_packet(const ::std::string& value) {
  _set_bit(0);
  if (packet_ == &_default_packet_) {
    packet_ = new ::std::string;
  }
  packet_->assign(value);
}
inline void UDPTunnel::set_packet(const char* value) {
  _set_bit(0);
  if (packet_ == &_default_packet_) {
    packet_ = new ::std::string;
  }
  packet_->assign(value);
}
inline void UDPTunnel::set_packet(const void* value, size_t size) {
  _set_bit(0);
  if (packet_ == &_default_packet_) {
    packet_ = new ::std::string;
  }
  packet_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UDPTunnel::mutable_packet() {
  _set_bit(0);
  if (packet_ == &_default_packet_) {
    packet_ = new ::std::string;
  }
  return packet_;
}

// -------------------------------------------------------------------

// Authenticate

// optional string username = 1;
inline bool Authenticate::has_username() const {
  return _has_bit(0);
}
inline void Authenticate::clear_username() {
  if (username_ != &_default_username_) {
    username_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Authenticate::username() const {
  return *username_;
}
inline void Authenticate::set_username(const ::std::string& value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Authenticate::set_username(const char* value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Authenticate::set_username(const char* value, size_t size) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Authenticate::mutable_username() {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  return username_;
}

// optional string password = 2;
inline bool Authenticate::has_password() const {
  return _has_bit(1);
}
inline void Authenticate::clear_password() {
  if (password_ != &_default_password_) {
    password_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Authenticate::password() const {
  return *password_;
}
inline void Authenticate::set_password(const ::std::string& value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Authenticate::set_password(const char* value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Authenticate::set_password(const char* value, size_t size) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Authenticate::mutable_password() {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  return password_;
}

// repeated string tokens = 3;
inline int Authenticate::tokens_size() const {
  return tokens_.size();
}
inline void Authenticate::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& Authenticate::tokens(int index) const {
  return tokens_.Get(index);
}
inline ::std::string* Authenticate::mutable_tokens(int index) {
  return tokens_.Mutable(index);
}
inline void Authenticate::set_tokens(int index, const ::std::string& value) {
  tokens_.Mutable(index)->assign(value);
}
inline void Authenticate::set_tokens(int index, const char* value) {
  tokens_.Mutable(index)->assign(value);
}
inline void Authenticate::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Authenticate::add_tokens() {
  return tokens_.Add();
}
inline void Authenticate::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
}
inline void Authenticate::add_tokens(const char* value) {
  tokens_.Add()->assign(value);
}
inline void Authenticate::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Authenticate::tokens() const {
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Authenticate::mutable_tokens() {
  return &tokens_;
}

// repeated int32 celt_versions = 4;
inline int Authenticate::celt_versions_size() const {
  return celt_versions_.size();
}
inline void Authenticate::clear_celt_versions() {
  celt_versions_.Clear();
}
inline ::google::protobuf::int32 Authenticate::celt_versions(int index) const {
  return celt_versions_.Get(index);
}
inline void Authenticate::set_celt_versions(int index, ::google::protobuf::int32 value) {
  celt_versions_.Set(index, value);
}
inline void Authenticate::add_celt_versions(::google::protobuf::int32 value) {
  celt_versions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Authenticate::celt_versions() const {
  return celt_versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Authenticate::mutable_celt_versions() {
  return &celt_versions_;
}

// -------------------------------------------------------------------

// Ping

// optional uint64 timestamp = 1;
inline bool Ping::has_timestamp() const {
  return _has_bit(0);
}
inline void Ping::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 Ping::timestamp() const {
  return timestamp_;
}
inline void Ping::set_timestamp(::google::protobuf::uint64 value) {
  _set_bit(0);
  timestamp_ = value;
}

// optional uint32 good = 2;
inline bool Ping::has_good() const {
  return _has_bit(1);
}
inline void Ping::clear_good() {
  good_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Ping::good() const {
  return good_;
}
inline void Ping::set_good(::google::protobuf::uint32 value) {
  _set_bit(1);
  good_ = value;
}

// optional uint32 late = 3;
inline bool Ping::has_late() const {
  return _has_bit(2);
}
inline void Ping::clear_late() {
  late_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 Ping::late() const {
  return late_;
}
inline void Ping::set_late(::google::protobuf::uint32 value) {
  _set_bit(2);
  late_ = value;
}

// optional uint32 lost = 4;
inline bool Ping::has_lost() const {
  return _has_bit(3);
}
inline void Ping::clear_lost() {
  lost_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 Ping::lost() const {
  return lost_;
}
inline void Ping::set_lost(::google::protobuf::uint32 value) {
  _set_bit(3);
  lost_ = value;
}

// optional uint32 resync = 5;
inline bool Ping::has_resync() const {
  return _has_bit(4);
}
inline void Ping::clear_resync() {
  resync_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 Ping::resync() const {
  return resync_;
}
inline void Ping::set_resync(::google::protobuf::uint32 value) {
  _set_bit(4);
  resync_ = value;
}

// optional uint32 udp_packets = 6;
inline bool Ping::has_udp_packets() const {
  return _has_bit(5);
}
inline void Ping::clear_udp_packets() {
  udp_packets_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 Ping::udp_packets() const {
  return udp_packets_;
}
inline void Ping::set_udp_packets(::google::protobuf::uint32 value) {
  _set_bit(5);
  udp_packets_ = value;
}

// optional uint32 tcp_packets = 7;
inline bool Ping::has_tcp_packets() const {
  return _has_bit(6);
}
inline void Ping::clear_tcp_packets() {
  tcp_packets_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 Ping::tcp_packets() const {
  return tcp_packets_;
}
inline void Ping::set_tcp_packets(::google::protobuf::uint32 value) {
  _set_bit(6);
  tcp_packets_ = value;
}

// optional float udp_ping_avg = 8;
inline bool Ping::has_udp_ping_avg() const {
  return _has_bit(7);
}
inline void Ping::clear_udp_ping_avg() {
  udp_ping_avg_ = 0;
  _clear_bit(7);
}
inline float Ping::udp_ping_avg() const {
  return udp_ping_avg_;
}
inline void Ping::set_udp_ping_avg(float value) {
  _set_bit(7);
  udp_ping_avg_ = value;
}

// optional float udp_ping_var = 9;
inline bool Ping::has_udp_ping_var() const {
  return _has_bit(8);
}
inline void Ping::clear_udp_ping_var() {
  udp_ping_var_ = 0;
  _clear_bit(8);
}
inline float Ping::udp_ping_var() const {
  return udp_ping_var_;
}
inline void Ping::set_udp_ping_var(float value) {
  _set_bit(8);
  udp_ping_var_ = value;
}

// optional float tcp_ping_avg = 10;
inline bool Ping::has_tcp_ping_avg() const {
  return _has_bit(9);
}
inline void Ping::clear_tcp_ping_avg() {
  tcp_ping_avg_ = 0;
  _clear_bit(9);
}
inline float Ping::tcp_ping_avg() const {
  return tcp_ping_avg_;
}
inline void Ping::set_tcp_ping_avg(float value) {
  _set_bit(9);
  tcp_ping_avg_ = value;
}

// optional float tcp_ping_var = 11;
inline bool Ping::has_tcp_ping_var() const {
  return _has_bit(10);
}
inline void Ping::clear_tcp_ping_var() {
  tcp_ping_var_ = 0;
  _clear_bit(10);
}
inline float Ping::tcp_ping_var() const {
  return tcp_ping_var_;
}
inline void Ping::set_tcp_ping_var(float value) {
  _set_bit(10);
  tcp_ping_var_ = value;
}

// -------------------------------------------------------------------

// Reject

// optional .MumbleProto.Reject.RejectType type = 1;
inline bool Reject::has_type() const {
  return _has_bit(0);
}
inline void Reject::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::MumbleProto::Reject_RejectType Reject::type() const {
  return static_cast< ::MumbleProto::Reject_RejectType >(type_);
}
inline void Reject::set_type(::MumbleProto::Reject_RejectType value) {
  GOOGLE_DCHECK(::MumbleProto::Reject_RejectType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional string reason = 2;
inline bool Reject::has_reason() const {
  return _has_bit(1);
}
inline void Reject::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Reject::reason() const {
  return *reason_;
}
inline void Reject::set_reason(const ::std::string& value) {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void Reject::set_reason(const char* value) {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void Reject::set_reason(const char* value, size_t size) {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reject::mutable_reason() {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// -------------------------------------------------------------------

// ServerSync

// optional uint32 session = 1;
inline bool ServerSync::has_session() const {
  return _has_bit(0);
}
inline void ServerSync::clear_session() {
  session_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ServerSync::session() const {
  return session_;
}
inline void ServerSync::set_session(::google::protobuf::uint32 value) {
  _set_bit(0);
  session_ = value;
}

// optional uint32 max_bandwidth = 2;
inline bool ServerSync::has_max_bandwidth() const {
  return _has_bit(1);
}
inline void ServerSync::clear_max_bandwidth() {
  max_bandwidth_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 ServerSync::max_bandwidth() const {
  return max_bandwidth_;
}
inline void ServerSync::set_max_bandwidth(::google::protobuf::uint32 value) {
  _set_bit(1);
  max_bandwidth_ = value;
}

// optional string welcome_text = 3;
inline bool ServerSync::has_welcome_text() const {
  return _has_bit(2);
}
inline void ServerSync::clear_welcome_text() {
  if (welcome_text_ != &_default_welcome_text_) {
    welcome_text_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ServerSync::welcome_text() const {
  return *welcome_text_;
}
inline void ServerSync::set_welcome_text(const ::std::string& value) {
  _set_bit(2);
  if (welcome_text_ == &_default_welcome_text_) {
    welcome_text_ = new ::std::string;
  }
  welcome_text_->assign(value);
}
inline void ServerSync::set_welcome_text(const char* value) {
  _set_bit(2);
  if (welcome_text_ == &_default_welcome_text_) {
    welcome_text_ = new ::std::string;
  }
  welcome_text_->assign(value);
}
inline void ServerSync::set_welcome_text(const char* value, size_t size) {
  _set_bit(2);
  if (welcome_text_ == &_default_welcome_text_) {
    welcome_text_ = new ::std::string;
  }
  welcome_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerSync::mutable_welcome_text() {
  _set_bit(2);
  if (welcome_text_ == &_default_welcome_text_) {
    welcome_text_ = new ::std::string;
  }
  return welcome_text_;
}

// optional uint64 permissions = 4;
inline bool ServerSync::has_permissions() const {
  return _has_bit(3);
}
inline void ServerSync::clear_permissions() {
  permissions_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 ServerSync::permissions() const {
  return permissions_;
}
inline void ServerSync::set_permissions(::google::protobuf::uint64 value) {
  _set_bit(3);
  permissions_ = value;
}

// optional bool allow_html = 5 [default = true];
inline bool ServerSync::has_allow_html() const {
  return _has_bit(4);
}
inline void ServerSync::clear_allow_html() {
  allow_html_ = true;
  _clear_bit(4);
}
inline bool ServerSync::allow_html() const {
  return allow_html_;
}
inline void ServerSync::set_allow_html(bool value) {
  _set_bit(4);
  allow_html_ = value;
}

// -------------------------------------------------------------------

// ChannelRemove

// required uint32 channel_id = 1;
inline bool ChannelRemove::has_channel_id() const {
  return _has_bit(0);
}
inline void ChannelRemove::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ChannelRemove::channel_id() const {
  return channel_id_;
}
inline void ChannelRemove::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  channel_id_ = value;
}

// -------------------------------------------------------------------

// ChannelState

// optional uint32 channel_id = 1;
inline bool ChannelState::has_channel_id() const {
  return _has_bit(0);
}
inline void ChannelState::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ChannelState::channel_id() const {
  return channel_id_;
}
inline void ChannelState::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  channel_id_ = value;
}

// optional uint32 parent = 2;
inline bool ChannelState::has_parent() const {
  return _has_bit(1);
}
inline void ChannelState::clear_parent() {
  parent_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 ChannelState::parent() const {
  return parent_;
}
inline void ChannelState::set_parent(::google::protobuf::uint32 value) {
  _set_bit(1);
  parent_ = value;
}

// optional string name = 3;
inline bool ChannelState::has_name() const {
  return _has_bit(2);
}
inline void ChannelState::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ChannelState::name() const {
  return *name_;
}
inline void ChannelState::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChannelState::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChannelState::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChannelState::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated uint32 links = 4;
inline int ChannelState::links_size() const {
  return links_.size();
}
inline void ChannelState::clear_links() {
  links_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links(int index) const {
  return links_.Get(index);
}
inline void ChannelState::set_links(int index, ::google::protobuf::uint32 value) {
  links_.Set(index, value);
}
inline void ChannelState::add_links(::google::protobuf::uint32 value) {
  links_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links() {
  return &links_;
}

// optional string description = 5;
inline bool ChannelState::has_description() const {
  return _has_bit(4);
}
inline void ChannelState::clear_description() {
  if (description_ != &_default_description_) {
    description_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ChannelState::description() const {
  return *description_;
}
inline void ChannelState::set_description(const ::std::string& value) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ChannelState::set_description(const char* value) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ChannelState::set_description(const char* value, size_t size) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChannelState::mutable_description() {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  return description_;
}

// repeated uint32 links_add = 6;
inline int ChannelState::links_add_size() const {
  return links_add_.size();
}
inline void ChannelState::clear_links_add() {
  links_add_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links_add(int index) const {
  return links_add_.Get(index);
}
inline void ChannelState::set_links_add(int index, ::google::protobuf::uint32 value) {
  links_add_.Set(index, value);
}
inline void ChannelState::add_links_add(::google::protobuf::uint32 value) {
  links_add_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links_add() const {
  return links_add_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links_add() {
  return &links_add_;
}

// repeated uint32 links_remove = 7;
inline int ChannelState::links_remove_size() const {
  return links_remove_.size();
}
inline void ChannelState::clear_links_remove() {
  links_remove_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links_remove(int index) const {
  return links_remove_.Get(index);
}
inline void ChannelState::set_links_remove(int index, ::google::protobuf::uint32 value) {
  links_remove_.Set(index, value);
}
inline void ChannelState::add_links_remove(::google::protobuf::uint32 value) {
  links_remove_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links_remove() const {
  return links_remove_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links_remove() {
  return &links_remove_;
}

// optional bool temporary = 8 [default = false];
inline bool ChannelState::has_temporary() const {
  return _has_bit(7);
}
inline void ChannelState::clear_temporary() {
  temporary_ = false;
  _clear_bit(7);
}
inline bool ChannelState::temporary() const {
  return temporary_;
}
inline void ChannelState::set_temporary(bool value) {
  _set_bit(7);
  temporary_ = value;
}

// optional int32 position = 9 [default = 0];
inline bool ChannelState::has_position() const {
  return _has_bit(8);
}
inline void ChannelState::clear_position() {
  position_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 ChannelState::position() const {
  return position_;
}
inline void ChannelState::set_position(::google::protobuf::int32 value) {
  _set_bit(8);
  position_ = value;
}

// -------------------------------------------------------------------

// UserRemove

// required uint32 session = 1;
inline bool UserRemove::has_session() const {
  return _has_bit(0);
}
inline void UserRemove::clear_session() {
  session_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 UserRemove::session() const {
  return session_;
}
inline void UserRemove::set_session(::google::protobuf::uint32 value) {
  _set_bit(0);
  session_ = value;
}

// optional uint32 actor = 2;
inline bool UserRemove::has_actor() const {
  return _has_bit(1);
}
inline void UserRemove::clear_actor() {
  actor_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 UserRemove::actor() const {
  return actor_;
}
inline void UserRemove::set_actor(::google::protobuf::uint32 value) {
  _set_bit(1);
  actor_ = value;
}

// optional string reason = 3;
inline bool UserRemove::has_reason() const {
  return _has_bit(2);
}
inline void UserRemove::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& UserRemove::reason() const {
  return *reason_;
}
inline void UserRemove::set_reason(const ::std::string& value) {
  _set_bit(2);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void UserRemove::set_reason(const char* value) {
  _set_bit(2);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void UserRemove::set_reason(const char* value, size_t size) {
  _set_bit(2);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserRemove::mutable_reason() {
  _set_bit(2);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// optional bool ban = 4;
inline bool UserRemove::has_ban() const {
  return _has_bit(3);
}
inline void UserRemove::clear_ban() {
  ban_ = false;
  _clear_bit(3);
}
inline bool UserRemove::ban() const {
  return ban_;
}
inline void UserRemove::set_ban(bool value) {
  _set_bit(3);
  ban_ = value;
}

// -------------------------------------------------------------------

// UserState

// optional uint32 session = 1;
inline bool UserState::has_session() const {
  return _has_bit(0);
}
inline void UserState::clear_session() {
  session_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 UserState::session() const {
  return session_;
}
inline void UserState::set_session(::google::protobuf::uint32 value) {
  _set_bit(0);
  session_ = value;
}

// optional uint32 actor = 2;
inline bool UserState::has_actor() const {
  return _has_bit(1);
}
inline void UserState::clear_actor() {
  actor_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 UserState::actor() const {
  return actor_;
}
inline void UserState::set_actor(::google::protobuf::uint32 value) {
  _set_bit(1);
  actor_ = value;
}

// optional string name = 3;
inline bool UserState::has_name() const {
  return _has_bit(2);
}
inline void UserState::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& UserState::name() const {
  return *name_;
}
inline void UserState::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserState::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserState::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserState::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional uint32 user_id = 4;
inline bool UserState::has_user_id() const {
  return _has_bit(3);
}
inline void UserState::clear_user_id() {
  user_id_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 UserState::user_id() const {
  return user_id_;
}
inline void UserState::set_user_id(::google::protobuf::uint32 value) {
  _set_bit(3);
  user_id_ = value;
}

// optional uint32 channel_id = 5;
inline bool UserState::has_channel_id() const {
  return _has_bit(4);
}
inline void UserState::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 UserState::channel_id() const {
  return channel_id_;
}
inline void UserState::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(4);
  channel_id_ = value;
}

// optional bool mute = 6;
inline bool UserState::has_mute() const {
  return _has_bit(5);
}
inline void UserState::clear_mute() {
  mute_ = false;
  _clear_bit(5);
}
inline bool UserState::mute() const {
  return mute_;
}
inline void UserState::set_mute(bool value) {
  _set_bit(5);
  mute_ = value;
}

// optional bool deaf = 7;
inline bool UserState::has_deaf() const {
  return _has_bit(6);
}
inline void UserState::clear_deaf() {
  deaf_ = false;
  _clear_bit(6);
}
inline bool UserState::deaf() const {
  return deaf_;
}
inline void UserState::set_deaf(bool value) {
  _set_bit(6);
  deaf_ = value;
}

// optional bool suppress = 8;
inline bool UserState::has_suppress() const {
  return _has_bit(7);
}
inline void UserState::clear_suppress() {
  suppress_ = false;
  _clear_bit(7);
}
inline bool UserState::suppress() const {
  return suppress_;
}
inline void UserState::set_suppress(bool value) {
  _set_bit(7);
  suppress_ = value;
}

// optional bool self_mute = 9;
inline bool UserState::has_self_mute() const {
  return _has_bit(8);
}
inline void UserState::clear_self_mute() {
  self_mute_ = false;
  _clear_bit(8);
}
inline bool UserState::self_mute() const {
  return self_mute_;
}
inline void UserState::set_self_mute(bool value) {
  _set_bit(8);
  self_mute_ = value;
}

// optional bool self_deaf = 10;
inline bool UserState::has_self_deaf() const {
  return _has_bit(9);
}
inline void UserState::clear_self_deaf() {
  self_deaf_ = false;
  _clear_bit(9);
}
inline bool UserState::self_deaf() const {
  return self_deaf_;
}
inline void UserState::set_self_deaf(bool value) {
  _set_bit(9);
  self_deaf_ = value;
}

// optional bytes texture = 11;
inline bool UserState::has_texture() const {
  return _has_bit(10);
}
inline void UserState::clear_texture() {
  if (texture_ != &_default_texture_) {
    texture_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& UserState::texture() const {
  return *texture_;
}
inline void UserState::set_texture(const ::std::string& value) {
  _set_bit(10);
  if (texture_ == &_default_texture_) {
    texture_ = new ::std::string;
  }
  texture_->assign(value);
}
inline void UserState::set_texture(const char* value) {
  _set_bit(10);
  if (texture_ == &_default_texture_) {
    texture_ = new ::std::string;
  }
  texture_->assign(value);
}
inline void UserState::set_texture(const void* value, size_t size) {
  _set_bit(10);
  if (texture_ == &_default_texture_) {
    texture_ = new ::std::string;
  }
  texture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserState::mutable_texture() {
  _set_bit(10);
  if (texture_ == &_default_texture_) {
    texture_ = new ::std::string;
  }
  return texture_;
}

// optional string plugin_context = 12;
inline bool UserState::has_plugin_context() const {
  return _has_bit(11);
}
inline void UserState::clear_plugin_context() {
  if (plugin_context_ != &_default_plugin_context_) {
    plugin_context_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& UserState::plugin_context() const {
  return *plugin_context_;
}
inline void UserState::set_plugin_context(const ::std::string& value) {
  _set_bit(11);
  if (plugin_context_ == &_default_plugin_context_) {
    plugin_context_ = new ::std::string;
  }
  plugin_context_->assign(value);
}
inline void UserState::set_plugin_context(const char* value) {
  _set_bit(11);
  if (plugin_context_ == &_default_plugin_context_) {
    plugin_context_ = new ::std::string;
  }
  plugin_context_->assign(value);
}
inline void UserState::set_plugin_context(const char* value, size_t size) {
  _set_bit(11);
  if (plugin_context_ == &_default_plugin_context_) {
    plugin_context_ = new ::std::string;
  }
  plugin_context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserState::mutable_plugin_context() {
  _set_bit(11);
  if (plugin_context_ == &_default_plugin_context_) {
    plugin_context_ = new ::std::string;
  }
  return plugin_context_;
}

// optional string plugin_identity = 13;
inline bool UserState::has_plugin_identity() const {
  return _has_bit(12);
}
inline void UserState::clear_plugin_identity() {
  if (plugin_identity_ != &_default_plugin_identity_) {
    plugin_identity_->clear();
  }
  _clear_bit(12);
}
inline const ::std::string& UserState::plugin_identity() const {
  return *plugin_identity_;
}
inline void UserState::set_plugin_identity(const ::std::string& value) {
  _set_bit(12);
  if (plugin_identity_ == &_default_plugin_identity_) {
    plugin_identity_ = new ::std::string;
  }
  plugin_identity_->assign(value);
}
inline void UserState::set_plugin_identity(const char* value) {
  _set_bit(12);
  if (plugin_identity_ == &_default_plugin_identity_) {
    plugin_identity_ = new ::std::string;
  }
  plugin_identity_->assign(value);
}
inline void UserState::set_plugin_identity(const char* value, size_t size) {
  _set_bit(12);
  if (plugin_identity_ == &_default_plugin_identity_) {
    plugin_identity_ = new ::std::string;
  }
  plugin_identity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserState::mutable_plugin_identity() {
  _set_bit(12);
  if (plugin_identity_ == &_default_plugin_identity_) {
    plugin_identity_ = new ::std::string;
  }
  return plugin_identity_;
}

// optional string comment = 14;
inline bool UserState::has_comment() const {
  return _has_bit(13);
}
inline void UserState::clear_comment() {
  if (comment_ != &_default_comment_) {
    comment_->clear();
  }
  _clear_bit(13);
}
inline const ::std::string& UserState::comment() const {
  return *comment_;
}
inline void UserState::set_comment(const ::std::string& value) {
  _set_bit(13);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void UserState::set_comment(const char* value) {
  _set_bit(13);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void UserState::set_comment(const char* value, size_t size) {
  _set_bit(13);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserState::mutable_comment() {
  _set_bit(13);
  if (comment_ == &_default_comment_) {
    comment_ = new ::std::string;
  }
  return comment_;
}

// optional string hash = 15;
inline bool UserState::has_hash() const {
  return _has_bit(14);
}
inline void UserState::clear_hash() {
  if (hash_ != &_default_hash_) {
    hash_->clear();
  }
  _clear_bit(14);
}
inline const ::std::string& UserState::hash() const {
  return *hash_;
}
inline void UserState::set_hash(const ::std::string& value) {
  _set_bit(14);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void UserState::set_hash(const char* value) {
  _set_bit(14);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void UserState::set_hash(const char* value, size_t size) {
  _set_bit(14);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserState::mutable_hash() {
  _set_bit(14);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  return hash_;
}

// -------------------------------------------------------------------

// BanList_BanEntry

// required bytes address = 1;
inline bool BanList_BanEntry::has_address() const {
  return _has_bit(0);
}
inline void BanList_BanEntry::clear_address() {
  if (address_ != &_default_address_) {
    address_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BanList_BanEntry::address() const {
  return *address_;
}
inline void BanList_BanEntry::set_address(const ::std::string& value) {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void BanList_BanEntry::set_address(const char* value) {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void BanList_BanEntry::set_address(const void* value, size_t size) {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanList_BanEntry::mutable_address() {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  return address_;
}

// required uint32 mask = 2;
inline bool BanList_BanEntry::has_mask() const {
  return _has_bit(1);
}
inline void BanList_BanEntry::clear_mask() {
  mask_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 BanList_BanEntry::mask() const {
  return mask_;
}
inline void BanList_BanEntry::set_mask(::google::protobuf::uint32 value) {
  _set_bit(1);
  mask_ = value;
}

// optional string name = 3;
inline bool BanList_BanEntry::has_name() const {
  return _has_bit(2);
}
inline void BanList_BanEntry::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& BanList_BanEntry::name() const {
  return *name_;
}
inline void BanList_BanEntry::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BanList_BanEntry::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BanList_BanEntry::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanList_BanEntry::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string hash = 4;
inline bool BanList_BanEntry::has_hash() const {
  return _has_bit(3);
}
inline void BanList_BanEntry::clear_hash() {
  if (hash_ != &_default_hash_) {
    hash_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& BanList_BanEntry::hash() const {
  return *hash_;
}
inline void BanList_BanEntry::set_hash(const ::std::string& value) {
  _set_bit(3);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void BanList_BanEntry::set_hash(const char* value) {
  _set_bit(3);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void BanList_BanEntry::set_hash(const char* value, size_t size) {
  _set_bit(3);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanList_BanEntry::mutable_hash() {
  _set_bit(3);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  return hash_;
}

// optional string reason = 5;
inline bool BanList_BanEntry::has_reason() const {
  return _has_bit(4);
}
inline void BanList_BanEntry::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& BanList_BanEntry::reason() const {
  return *reason_;
}
inline void BanList_BanEntry::set_reason(const ::std::string& value) {
  _set_bit(4);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void BanList_BanEntry::set_reason(const char* value) {
  _set_bit(4);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void BanList_BanEntry::set_reason(const char* value, size_t size) {
  _set_bit(4);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanList_BanEntry::mutable_reason() {
  _set_bit(4);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// optional string start = 6;
inline bool BanList_BanEntry::has_start() const {
  return _has_bit(5);
}
inline void BanList_BanEntry::clear_start() {
  if (start_ != &_default_start_) {
    start_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& BanList_BanEntry::start() const {
  return *start_;
}
inline void BanList_BanEntry::set_start(const ::std::string& value) {
  _set_bit(5);
  if (start_ == &_default_start_) {
    start_ = new ::std::string;
  }
  start_->assign(value);
}
inline void BanList_BanEntry::set_start(const char* value) {
  _set_bit(5);
  if (start_ == &_default_start_) {
    start_ = new ::std::string;
  }
  start_->assign(value);
}
inline void BanList_BanEntry::set_start(const char* value, size_t size) {
  _set_bit(5);
  if (start_ == &_default_start_) {
    start_ = new ::std::string;
  }
  start_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BanList_BanEntry::mutable_start() {
  _set_bit(5);
  if (start_ == &_default_start_) {
    start_ = new ::std::string;
  }
  return start_;
}

// optional uint32 duration = 7;
inline bool BanList_BanEntry::has_duration() const {
  return _has_bit(6);
}
inline void BanList_BanEntry::clear_duration() {
  duration_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 BanList_BanEntry::duration() const {
  return duration_;
}
inline void BanList_BanEntry::set_duration(::google::protobuf::uint32 value) {
  _set_bit(6);
  duration_ = value;
}

// -------------------------------------------------------------------

// BanList

// repeated .MumbleProto.BanList.BanEntry bans = 1;
inline int BanList::bans_size() const {
  return bans_.size();
}
inline void BanList::clear_bans() {
  bans_.Clear();
}
inline const ::MumbleProto::BanList_BanEntry& BanList::bans(int index) const {
  return bans_.Get(index);
}
inline ::MumbleProto::BanList_BanEntry* BanList::mutable_bans(int index) {
  return bans_.Mutable(index);
}
inline ::MumbleProto::BanList_BanEntry* BanList::add_bans() {
  return bans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
BanList::bans() const {
  return bans_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
BanList::mutable_bans() {
  return &bans_;
}

// optional bool query = 2 [default = false];
inline bool BanList::has_query() const {
  return _has_bit(1);
}
inline void BanList::clear_query() {
  query_ = false;
  _clear_bit(1);
}
inline bool BanList::query() const {
  return query_;
}
inline void BanList::set_query(bool value) {
  _set_bit(1);
  query_ = value;
}

// -------------------------------------------------------------------

// TextMessage

// optional uint32 actor = 1;
inline bool TextMessage::has_actor() const {
  return _has_bit(0);
}
inline void TextMessage::clear_actor() {
  actor_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 TextMessage::actor() const {
  return actor_;
}
inline void TextMessage::set_actor(::google::protobuf::uint32 value) {
  _set_bit(0);
  actor_ = value;
}

// repeated uint32 session = 2;
inline int TextMessage::session_size() const {
  return session_.size();
}
inline void TextMessage::clear_session() {
  session_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::session(int index) const {
  return session_.Get(index);
}
inline void TextMessage::set_session(int index, ::google::protobuf::uint32 value) {
  session_.Set(index, value);
}
inline void TextMessage::add_session(::google::protobuf::uint32 value) {
  session_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::session() const {
  return session_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_session() {
  return &session_;
}

// repeated uint32 channel_id = 3;
inline int TextMessage::channel_id_size() const {
  return channel_id_.size();
}
inline void TextMessage::clear_channel_id() {
  channel_id_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::channel_id(int index) const {
  return channel_id_.Get(index);
}
inline void TextMessage::set_channel_id(int index, ::google::protobuf::uint32 value) {
  channel_id_.Set(index, value);
}
inline void TextMessage::add_channel_id(::google::protobuf::uint32 value) {
  channel_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::channel_id() const {
  return channel_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_channel_id() {
  return &channel_id_;
}

// repeated uint32 tree_id = 4;
inline int TextMessage::tree_id_size() const {
  return tree_id_.size();
}
inline void TextMessage::clear_tree_id() {
  tree_id_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::tree_id(int index) const {
  return tree_id_.Get(index);
}
inline void TextMessage::set_tree_id(int index, ::google::protobuf::uint32 value) {
  tree_id_.Set(index, value);
}
inline void TextMessage::add_tree_id(::google::protobuf::uint32 value) {
  tree_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::tree_id() const {
  return tree_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_tree_id() {
  return &tree_id_;
}

// required string message = 5;
inline bool TextMessage::has_message() const {
  return _has_bit(4);
}
inline void TextMessage::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& TextMessage::message() const {
  return *message_;
}
inline void TextMessage::set_message(const ::std::string& value) {
  _set_bit(4);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TextMessage::set_message(const char* value) {
  _set_bit(4);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TextMessage::set_message(const char* value, size_t size) {
  _set_bit(4);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextMessage::mutable_message() {
  _set_bit(4);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// PermissionDenied

// optional uint32 permission = 1;
inline bool PermissionDenied::has_permission() const {
  return _has_bit(0);
}
inline void PermissionDenied::clear_permission() {
  permission_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 PermissionDenied::permission() const {
  return permission_;
}
inline void PermissionDenied::set_permission(::google::protobuf::uint32 value) {
  _set_bit(0);
  permission_ = value;
}

// optional uint32 channel_id = 2;
inline bool PermissionDenied::has_channel_id() const {
  return _has_bit(1);
}
inline void PermissionDenied::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 PermissionDenied::channel_id() const {
  return channel_id_;
}
inline void PermissionDenied::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  channel_id_ = value;
}

// optional uint32 session = 3;
inline bool PermissionDenied::has_session() const {
  return _has_bit(2);
}
inline void PermissionDenied::clear_session() {
  session_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 PermissionDenied::session() const {
  return session_;
}
inline void PermissionDenied::set_session(::google::protobuf::uint32 value) {
  _set_bit(2);
  session_ = value;
}

// optional string reason = 4;
inline bool PermissionDenied::has_reason() const {
  return _has_bit(3);
}
inline void PermissionDenied::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PermissionDenied::reason() const {
  return *reason_;
}
inline void PermissionDenied::set_reason(const ::std::string& value) {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void PermissionDenied::set_reason(const char* value) {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void PermissionDenied::set_reason(const char* value, size_t size) {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PermissionDenied::mutable_reason() {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// optional .MumbleProto.PermissionDenied.DenyType type = 5;
inline bool PermissionDenied::has_type() const {
  return _has_bit(4);
}
inline void PermissionDenied::clear_type() {
  type_ = 0;
  _clear_bit(4);
}
inline ::MumbleProto::PermissionDenied_DenyType PermissionDenied::type() const {
  return static_cast< ::MumbleProto::PermissionDenied_DenyType >(type_);
}
inline void PermissionDenied::set_type(::MumbleProto::PermissionDenied_DenyType value) {
  GOOGLE_DCHECK(::MumbleProto::PermissionDenied_DenyType_IsValid(value));
  _set_bit(4);
  type_ = value;
}

// optional string name = 6;
inline bool PermissionDenied::has_name() const {
  return _has_bit(5);
}
inline void PermissionDenied::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& PermissionDenied::name() const {
  return *name_;
}
inline void PermissionDenied::set_name(const ::std::string& value) {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PermissionDenied::set_name(const char* value) {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PermissionDenied::set_name(const char* value, size_t size) {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PermissionDenied::mutable_name() {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// ACL_ChanGroup

// required string name = 1;
inline bool ACL_ChanGroup::has_name() const {
  return _has_bit(0);
}
inline void ACL_ChanGroup::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ACL_ChanGroup::name() const {
  return *name_;
}
inline void ACL_ChanGroup::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ACL_ChanGroup::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ACL_ChanGroup::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACL_ChanGroup::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional bool inherited = 2 [default = true];
inline bool ACL_ChanGroup::has_inherited() const {
  return _has_bit(1);
}
inline void ACL_ChanGroup::clear_inherited() {
  inherited_ = true;
  _clear_bit(1);
}
inline bool ACL_ChanGroup::inherited() const {
  return inherited_;
}
inline void ACL_ChanGroup::set_inherited(bool value) {
  _set_bit(1);
  inherited_ = value;
}

// optional bool inherit = 3 [default = true];
inline bool ACL_ChanGroup::has_inherit() const {
  return _has_bit(2);
}
inline void ACL_ChanGroup::clear_inherit() {
  inherit_ = true;
  _clear_bit(2);
}
inline bool ACL_ChanGroup::inherit() const {
  return inherit_;
}
inline void ACL_ChanGroup::set_inherit(bool value) {
  _set_bit(2);
  inherit_ = value;
}

// optional bool inheritable = 4 [default = true];
inline bool ACL_ChanGroup::has_inheritable() const {
  return _has_bit(3);
}
inline void ACL_ChanGroup::clear_inheritable() {
  inheritable_ = true;
  _clear_bit(3);
}
inline bool ACL_ChanGroup::inheritable() const {
  return inheritable_;
}
inline void ACL_ChanGroup::set_inheritable(bool value) {
  _set_bit(3);
  inheritable_ = value;
}

// repeated uint32 add = 5;
inline int ACL_ChanGroup::add_size() const {
  return add_.size();
}
inline void ACL_ChanGroup::clear_add() {
  add_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::add(int index) const {
  return add_.Get(index);
}
inline void ACL_ChanGroup::set_add(int index, ::google::protobuf::uint32 value) {
  add_.Set(index, value);
}
inline void ACL_ChanGroup::add_add(::google::protobuf::uint32 value) {
  add_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::add() const {
  return add_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_add() {
  return &add_;
}

// repeated uint32 remove = 6;
inline int ACL_ChanGroup::remove_size() const {
  return remove_.size();
}
inline void ACL_ChanGroup::clear_remove() {
  remove_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::remove(int index) const {
  return remove_.Get(index);
}
inline void ACL_ChanGroup::set_remove(int index, ::google::protobuf::uint32 value) {
  remove_.Set(index, value);
}
inline void ACL_ChanGroup::add_remove(::google::protobuf::uint32 value) {
  remove_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::remove() const {
  return remove_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_remove() {
  return &remove_;
}

// repeated uint32 inherited_members = 7;
inline int ACL_ChanGroup::inherited_members_size() const {
  return inherited_members_.size();
}
inline void ACL_ChanGroup::clear_inherited_members() {
  inherited_members_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::inherited_members(int index) const {
  return inherited_members_.Get(index);
}
inline void ACL_ChanGroup::set_inherited_members(int index, ::google::protobuf::uint32 value) {
  inherited_members_.Set(index, value);
}
inline void ACL_ChanGroup::add_inherited_members(::google::protobuf::uint32 value) {
  inherited_members_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::inherited_members() const {
  return inherited_members_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_inherited_members() {
  return &inherited_members_;
}

// -------------------------------------------------------------------

// ACL_ChanACL

// optional bool apply_here = 1 [default = true];
inline bool ACL_ChanACL::has_apply_here() const {
  return _has_bit(0);
}
inline void ACL_ChanACL::clear_apply_here() {
  apply_here_ = true;
  _clear_bit(0);
}
inline bool ACL_ChanACL::apply_here() const {
  return apply_here_;
}
inline void ACL_ChanACL::set_apply_here(bool value) {
  _set_bit(0);
  apply_here_ = value;
}

// optional bool apply_subs = 2 [default = true];
inline bool ACL_ChanACL::has_apply_subs() const {
  return _has_bit(1);
}
inline void ACL_ChanACL::clear_apply_subs() {
  apply_subs_ = true;
  _clear_bit(1);
}
inline bool ACL_ChanACL::apply_subs() const {
  return apply_subs_;
}
inline void ACL_ChanACL::set_apply_subs(bool value) {
  _set_bit(1);
  apply_subs_ = value;
}

// optional bool inherited = 3 [default = true];
inline bool ACL_ChanACL::has_inherited() const {
  return _has_bit(2);
}
inline void ACL_ChanACL::clear_inherited() {
  inherited_ = true;
  _clear_bit(2);
}
inline bool ACL_ChanACL::inherited() const {
  return inherited_;
}
inline void ACL_ChanACL::set_inherited(bool value) {
  _set_bit(2);
  inherited_ = value;
}

// optional uint32 user_id = 4;
inline bool ACL_ChanACL::has_user_id() const {
  return _has_bit(3);
}
inline void ACL_ChanACL::clear_user_id() {
  user_id_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 ACL_ChanACL::user_id() const {
  return user_id_;
}
inline void ACL_ChanACL::set_user_id(::google::protobuf::uint32 value) {
  _set_bit(3);
  user_id_ = value;
}

// optional string group = 5;
inline bool ACL_ChanACL::has_group() const {
  return _has_bit(4);
}
inline void ACL_ChanACL::clear_group() {
  if (group_ != &_default_group_) {
    group_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ACL_ChanACL::group() const {
  return *group_;
}
inline void ACL_ChanACL::set_group(const ::std::string& value) {
  _set_bit(4);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void ACL_ChanACL::set_group(const char* value) {
  _set_bit(4);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void ACL_ChanACL::set_group(const char* value, size_t size) {
  _set_bit(4);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACL_ChanACL::mutable_group() {
  _set_bit(4);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  return group_;
}

// optional uint32 grant = 6;
inline bool ACL_ChanACL::has_grant() const {
  return _has_bit(5);
}
inline void ACL_ChanACL::clear_grant() {
  grant_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 ACL_ChanACL::grant() const {
  return grant_;
}
inline void ACL_ChanACL::set_grant(::google::protobuf::uint32 value) {
  _set_bit(5);
  grant_ = value;
}

// optional uint32 deny = 7;
inline bool ACL_ChanACL::has_deny() const {
  return _has_bit(6);
}
inline void ACL_ChanACL::clear_deny() {
  deny_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 ACL_ChanACL::deny() const {
  return deny_;
}
inline void ACL_ChanACL::set_deny(::google::protobuf::uint32 value) {
  _set_bit(6);
  deny_ = value;
}

// -------------------------------------------------------------------

// ACL

// required uint32 channel_id = 1;
inline bool ACL::has_channel_id() const {
  return _has_bit(0);
}
inline void ACL::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ACL::channel_id() const {
  return channel_id_;
}
inline void ACL::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  channel_id_ = value;
}

// optional bool inherit_acls = 2 [default = true];
inline bool ACL::has_inherit_acls() const {
  return _has_bit(1);
}
inline void ACL::clear_inherit_acls() {
  inherit_acls_ = true;
  _clear_bit(1);
}
inline bool ACL::inherit_acls() const {
  return inherit_acls_;
}
inline void ACL::set_inherit_acls(bool value) {
  _set_bit(1);
  inherit_acls_ = value;
}

// repeated .MumbleProto.ACL.ChanGroup groups = 3;
inline int ACL::groups_size() const {
  return groups_.size();
}
inline void ACL::clear_groups() {
  groups_.Clear();
}
inline const ::MumbleProto::ACL_ChanGroup& ACL::groups(int index) const {
  return groups_.Get(index);
}
inline ::MumbleProto::ACL_ChanGroup* ACL::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::MumbleProto::ACL_ChanGroup* ACL::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
ACL::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
ACL::mutable_groups() {
  return &groups_;
}

// repeated .MumbleProto.ACL.ChanACL acls = 4;
inline int ACL::acls_size() const {
  return acls_.size();
}
inline void ACL::clear_acls() {
  acls_.Clear();
}
inline const ::MumbleProto::ACL_ChanACL& ACL::acls(int index) const {
  return acls_.Get(index);
}
inline ::MumbleProto::ACL_ChanACL* ACL::mutable_acls(int index) {
  return acls_.Mutable(index);
}
inline ::MumbleProto::ACL_ChanACL* ACL::add_acls() {
  return acls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
ACL::acls() const {
  return acls_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
ACL::mutable_acls() {
  return &acls_;
}

// optional bool query = 5 [default = false];
inline bool ACL::has_query() const {
  return _has_bit(4);
}
inline void ACL::clear_query() {
  query_ = false;
  _clear_bit(4);
}
inline bool ACL::query() const {
  return query_;
}
inline void ACL::set_query(bool value) {
  _set_bit(4);
  query_ = value;
}

// -------------------------------------------------------------------

// QueryUsers

// repeated uint32 ids = 1;
inline int QueryUsers::ids_size() const {
  return ids_.size();
}
inline void QueryUsers::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint32 QueryUsers::ids(int index) const {
  return ids_.Get(index);
}
inline void QueryUsers::set_ids(int index, ::google::protobuf::uint32 value) {
  ids_.Set(index, value);
}
inline void QueryUsers::add_ids(::google::protobuf::uint32 value) {
  ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
QueryUsers::ids() const {
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
QueryUsers::mutable_ids() {
  return &ids_;
}

// repeated string names = 2;
inline int QueryUsers::names_size() const {
  return names_.size();
}
inline void QueryUsers::clear_names() {
  names_.Clear();
}
inline const ::std::string& QueryUsers::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* QueryUsers::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void QueryUsers::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void QueryUsers::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void QueryUsers::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryUsers::add_names() {
  return names_.Add();
}
inline void QueryUsers::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void QueryUsers::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void QueryUsers::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryUsers::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryUsers::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// CryptSetup

// optional bytes key = 1;
inline bool CryptSetup::has_key() const {
  return _has_bit(0);
}
inline void CryptSetup::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CryptSetup::key() const {
  return *key_;
}
inline void CryptSetup::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CryptSetup::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CryptSetup::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSetup::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional bytes client_nonce = 2;
inline bool CryptSetup::has_client_nonce() const {
  return _has_bit(1);
}
inline void CryptSetup::clear_client_nonce() {
  if (client_nonce_ != &_default_client_nonce_) {
    client_nonce_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CryptSetup::client_nonce() const {
  return *client_nonce_;
}
inline void CryptSetup::set_client_nonce(const ::std::string& value) {
  _set_bit(1);
  if (client_nonce_ == &_default_client_nonce_) {
    client_nonce_ = new ::std::string;
  }
  client_nonce_->assign(value);
}
inline void CryptSetup::set_client_nonce(const char* value) {
  _set_bit(1);
  if (client_nonce_ == &_default_client_nonce_) {
    client_nonce_ = new ::std::string;
  }
  client_nonce_->assign(value);
}
inline void CryptSetup::set_client_nonce(const void* value, size_t size) {
  _set_bit(1);
  if (client_nonce_ == &_default_client_nonce_) {
    client_nonce_ = new ::std::string;
  }
  client_nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSetup::mutable_client_nonce() {
  _set_bit(1);
  if (client_nonce_ == &_default_client_nonce_) {
    client_nonce_ = new ::std::string;
  }
  return client_nonce_;
}

// optional bytes server_nonce = 3;
inline bool CryptSetup::has_server_nonce() const {
  return _has_bit(2);
}
inline void CryptSetup::clear_server_nonce() {
  if (server_nonce_ != &_default_server_nonce_) {
    server_nonce_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CryptSetup::server_nonce() const {
  return *server_nonce_;
}
inline void CryptSetup::set_server_nonce(const ::std::string& value) {
  _set_bit(2);
  if (server_nonce_ == &_default_server_nonce_) {
    server_nonce_ = new ::std::string;
  }
  server_nonce_->assign(value);
}
inline void CryptSetup::set_server_nonce(const char* value) {
  _set_bit(2);
  if (server_nonce_ == &_default_server_nonce_) {
    server_nonce_ = new ::std::string;
  }
  server_nonce_->assign(value);
}
inline void CryptSetup::set_server_nonce(const void* value, size_t size) {
  _set_bit(2);
  if (server_nonce_ == &_default_server_nonce_) {
    server_nonce_ = new ::std::string;
  }
  server_nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSetup::mutable_server_nonce() {
  _set_bit(2);
  if (server_nonce_ == &_default_server_nonce_) {
    server_nonce_ = new ::std::string;
  }
  return server_nonce_;
}

// -------------------------------------------------------------------

// ContextActionAdd

// required string action = 1;
inline bool ContextActionAdd::has_action() const {
  return _has_bit(0);
}
inline void ContextActionAdd::clear_action() {
  if (action_ != &_default_action_) {
    action_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ContextActionAdd::action() const {
  return *action_;
}
inline void ContextActionAdd::set_action(const ::std::string& value) {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void ContextActionAdd::set_action(const char* value) {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void ContextActionAdd::set_action(const char* value, size_t size) {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContextActionAdd::mutable_action() {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  return action_;
}

// required string text = 2;
inline bool ContextActionAdd::has_text() const {
  return _has_bit(1);
}
inline void ContextActionAdd::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ContextActionAdd::text() const {
  return *text_;
}
inline void ContextActionAdd::set_text(const ::std::string& value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ContextActionAdd::set_text(const char* value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ContextActionAdd::set_text(const char* value, size_t size) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContextActionAdd::mutable_text() {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}

// optional uint32 context = 3;
inline bool ContextActionAdd::has_context() const {
  return _has_bit(2);
}
inline void ContextActionAdd::clear_context() {
  context_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 ContextActionAdd::context() const {
  return context_;
}
inline void ContextActionAdd::set_context(::google::protobuf::uint32 value) {
  _set_bit(2);
  context_ = value;
}

// -------------------------------------------------------------------

// ContextAction

// optional uint32 session = 1;
inline bool ContextAction::has_session() const {
  return _has_bit(0);
}
inline void ContextAction::clear_session() {
  session_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ContextAction::session() const {
  return session_;
}
inline void ContextAction::set_session(::google::protobuf::uint32 value) {
  _set_bit(0);
  session_ = value;
}

// optional uint32 channel_id = 2;
inline bool ContextAction::has_channel_id() const {
  return _has_bit(1);
}
inline void ContextAction::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 ContextAction::channel_id() const {
  return channel_id_;
}
inline void ContextAction::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  channel_id_ = value;
}

// required string action = 3;
inline bool ContextAction::has_action() const {
  return _has_bit(2);
}
inline void ContextAction::clear_action() {
  if (action_ != &_default_action_) {
    action_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ContextAction::action() const {
  return *action_;
}
inline void ContextAction::set_action(const ::std::string& value) {
  _set_bit(2);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void ContextAction::set_action(const char* value) {
  _set_bit(2);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void ContextAction::set_action(const char* value, size_t size) {
  _set_bit(2);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContextAction::mutable_action() {
  _set_bit(2);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  return action_;
}

// -------------------------------------------------------------------

// UserList_User

// required uint32 user_id = 1;
inline bool UserList_User::has_user_id() const {
  return _has_bit(0);
}
inline void UserList_User::clear_user_id() {
  user_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 UserList_User::user_id() const {
  return user_id_;
}
inline void UserList_User::set_user_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  user_id_ = value;
}

// optional string name = 2;
inline bool UserList_User::has_name() const {
  return _has_bit(1);
}
inline void UserList_User::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UserList_User::name() const {
  return *name_;
}
inline void UserList_User::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserList_User::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserList_User::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserList_User::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// UserList

// repeated .MumbleProto.UserList.User users = 1;
inline int UserList::users_size() const {
  return users_.size();
}
inline void UserList::clear_users() {
  users_.Clear();
}
inline const ::MumbleProto::UserList_User& UserList::users(int index) const {
  return users_.Get(index);
}
inline ::MumbleProto::UserList_User* UserList::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::MumbleProto::UserList_User* UserList::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
UserList::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
UserList::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// VoiceTarget_Target

// repeated uint32 session = 1;
inline int VoiceTarget_Target::session_size() const {
  return session_.size();
}
inline void VoiceTarget_Target::clear_session() {
  session_.Clear();
}
inline ::google::protobuf::uint32 VoiceTarget_Target::session(int index) const {
  return session_.Get(index);
}
inline void VoiceTarget_Target::set_session(int index, ::google::protobuf::uint32 value) {
  session_.Set(index, value);
}
inline void VoiceTarget_Target::add_session(::google::protobuf::uint32 value) {
  session_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VoiceTarget_Target::session() const {
  return session_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VoiceTarget_Target::mutable_session() {
  return &session_;
}

// optional uint32 channel_id = 2;
inline bool VoiceTarget_Target::has_channel_id() const {
  return _has_bit(1);
}
inline void VoiceTarget_Target::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 VoiceTarget_Target::channel_id() const {
  return channel_id_;
}
inline void VoiceTarget_Target::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  channel_id_ = value;
}

// optional string group = 3;
inline bool VoiceTarget_Target::has_group() const {
  return _has_bit(2);
}
inline void VoiceTarget_Target::clear_group() {
  if (group_ != &_default_group_) {
    group_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& VoiceTarget_Target::group() const {
  return *group_;
}
inline void VoiceTarget_Target::set_group(const ::std::string& value) {
  _set_bit(2);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void VoiceTarget_Target::set_group(const char* value) {
  _set_bit(2);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void VoiceTarget_Target::set_group(const char* value, size_t size) {
  _set_bit(2);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VoiceTarget_Target::mutable_group() {
  _set_bit(2);
  if (group_ == &_default_group_) {
    group_ = new ::std::string;
  }
  return group_;
}

// optional bool links = 4 [default = false];
inline bool VoiceTarget_Target::has_links() const {
  return _has_bit(3);
}
inline void VoiceTarget_Target::clear_links() {
  links_ = false;
  _clear_bit(3);
}
inline bool VoiceTarget_Target::links() const {
  return links_;
}
inline void VoiceTarget_Target::set_links(bool value) {
  _set_bit(3);
  links_ = value;
}

// optional bool children = 5 [default = false];
inline bool VoiceTarget_Target::has_children() const {
  return _has_bit(4);
}
inline void VoiceTarget_Target::clear_children() {
  children_ = false;
  _clear_bit(4);
}
inline bool VoiceTarget_Target::children() const {
  return children_;
}
inline void VoiceTarget_Target::set_children(bool value) {
  _set_bit(4);
  children_ = value;
}

// -------------------------------------------------------------------

// VoiceTarget

// optional uint32 id = 1;
inline bool VoiceTarget::has_id() const {
  return _has_bit(0);
}
inline void VoiceTarget::clear_id() {
  id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 VoiceTarget::id() const {
  return id_;
}
inline void VoiceTarget::set_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  id_ = value;
}

// repeated .MumbleProto.VoiceTarget.Target targets = 2;
inline int VoiceTarget::targets_size() const {
  return targets_.size();
}
inline void VoiceTarget::clear_targets() {
  targets_.Clear();
}
inline const ::MumbleProto::VoiceTarget_Target& VoiceTarget::targets(int index) const {
  return targets_.Get(index);
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::mutable_targets(int index) {
  return targets_.Mutable(index);
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::add_targets() {
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
VoiceTarget::targets() const {
  return targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
VoiceTarget::mutable_targets() {
  return &targets_;
}

// -------------------------------------------------------------------

// PermissionQuery

// optional uint32 channel_id = 1;
inline bool PermissionQuery::has_channel_id() const {
  return _has_bit(0);
}
inline void PermissionQuery::clear_channel_id() {
  channel_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 PermissionQuery::channel_id() const {
  return channel_id_;
}
inline void PermissionQuery::set_channel_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  channel_id_ = value;
}

// optional uint32 permissions = 2;
inline bool PermissionQuery::has_permissions() const {
  return _has_bit(1);
}
inline void PermissionQuery::clear_permissions() {
  permissions_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 PermissionQuery::permissions() const {
  return permissions_;
}
inline void PermissionQuery::set_permissions(::google::protobuf::uint32 value) {
  _set_bit(1);
  permissions_ = value;
}

// optional bool flush = 3 [default = false];
inline bool PermissionQuery::has_flush() const {
  return _has_bit(2);
}
inline void PermissionQuery::clear_flush() {
  flush_ = false;
  _clear_bit(2);
}
inline bool PermissionQuery::flush() const {
  return flush_;
}
inline void PermissionQuery::set_flush(bool value) {
  _set_bit(2);
  flush_ = value;
}

// -------------------------------------------------------------------

// CodecVersion

// required int32 alpha = 1;
inline bool CodecVersion::has_alpha() const {
  return _has_bit(0);
}
inline void CodecVersion::clear_alpha() {
  alpha_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 CodecVersion::alpha() const {
  return alpha_;
}
inline void CodecVersion::set_alpha(::google::protobuf::int32 value) {
  _set_bit(0);
  alpha_ = value;
}

// required int32 beta = 2;
inline bool CodecVersion::has_beta() const {
  return _has_bit(1);
}
inline void CodecVersion::clear_beta() {
  beta_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 CodecVersion::beta() const {
  return beta_;
}
inline void CodecVersion::set_beta(::google::protobuf::int32 value) {
  _set_bit(1);
  beta_ = value;
}

// required bool prefer_alpha = 3 [default = true];
inline bool CodecVersion::has_prefer_alpha() const {
  return _has_bit(2);
}
inline void CodecVersion::clear_prefer_alpha() {
  prefer_alpha_ = true;
  _clear_bit(2);
}
inline bool CodecVersion::prefer_alpha() const {
  return prefer_alpha_;
}
inline void CodecVersion::set_prefer_alpha(bool value) {
  _set_bit(2);
  prefer_alpha_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MumbleProto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::Reject_RejectType>() {
  return ::MumbleProto::Reject_RejectType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::PermissionDenied_DenyType>() {
  return ::MumbleProto::PermissionDenied_DenyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::ContextActionAdd_Context>() {
  return ::MumbleProto::ContextActionAdd_Context_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Mumble_2eproto__INCLUDED
